from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters, CallbackQueryHandler
import math
import sqlite3
import os
import logging
import asyncio
import sys
import re
from datetime import datetime, timedelta
import random
import string
import time
import traceback
from dotenv import load_dotenv
import requests
import psutil  # optional: for robust PID check (install psutil) or use os

load_dotenv()  # Ø³ÙŠØ­Ù…Ù‘Ù„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ù† .env ÙÙŠ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹

# Ø¥Ø³ÙƒØ§Øª ØªØ­Ø°ÙŠØ±Ø§Øª Deprecation Ø§Ù„Ø¹Ø§Ù…Ø© Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ asyncio.WindowsSelectorEventLoopPolicy
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO)

TOKEN = os.getenv("BOT_TOKEN")
if not TOKEN:
    raise SystemExit("BOT_TOKEN missing")
DATA_ENC_KEY = os.getenv("DATA_ENC_KEY")
if not DATA_ENC_KEY:
    raise SystemExit("DATA_ENC_KEY missing")
try:
    ADMIN_ID = int(os.getenv("ADMIN_USER_ID", "0")) or 0
except Exception:
    ADMIN_ID = 0

# Broadcast throttling defaults (batch size and delay between batches in seconds)
BROADCAST_BATCH_SIZE = int(os.getenv("BROADCAST_BATCH_SIZE", "20"))
BROADCAST_BATCH_DELAY = float(os.getenv("BROADCAST_BATCH_DELAY", "1.0"))

# Service categorization: top-level categories map to lists of services.
# This presents a two-level menu: categories -> services. Keep WORK_TYPES
# as a flat list derived from the categories so existing checks (text in WORK_TYPES)
# continue to work.
SERVICE_CATEGORIES = {
    "ğŸ  ØµÙŠØ§Ù†Ø© Ù…Ù†Ø²Ù„ÙŠØ©": [
        "Ø³Ø¨Ø§ÙƒØ©",
        "Ø·Ù„Ø§Ø¡ Ù…Ù†Ø§Ø²Ù„",
        "ØªØ±ÙƒÙŠØ¨ Ø§Ù„Ø£Ø«Ø§Ø«",
        "Ø£Ø±Ø¶ÙŠØ§Øª",
    ],
    "ğŸ”ŒğŸŒ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© ÙˆØ§Ù„ØªÙ‚Ù†ÙŠØ©": [
        "ØªØ±ÙƒÙŠØ¨ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª",
        "ÙÙ†ÙŠ Ø§Ù†ØªØ±Ù†Øª",
        "ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ Ù…Ù†Ø§Ø²Ù„",
    ],
    "ğŸ‘©â€ğŸ”§ Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù†Ø¸Ø§ÙØ© Ø§Ù„Ù…Ù†Ø²Ù„ÙŠØ©": [
        "Ø¹Ø§Ù…Ù„Ø§Øª Ù†Ø¸Ø§ÙØ© ÙˆØ£Ø´ØºØ§Ù„ Ø¹Ø§Ù…Ø©",
        "ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¬Ø§Ø¯ Ùˆ Ø§Ù„Ù…ÙØ±ÙˆØ´Ø§Øª ÙÙŠ Ø§Ù„Ù…Ù†Ø²Ù„",
    ],
    "ğŸšš Ø§Ù„Ù†Ù‚Ù„ ÙˆØ§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙŠØ¯Ø§Ù†ÙŠØ©": [
        "ØªÙˆØµÙŠÙ„ Ø±Ø¬Ø§Ù„ÙŠ",
        "ØªÙˆØµÙŠÙ„ Ù†Ø³Ø§Ø¦ÙŠ",
        "Ø³ÙŠØ§Ø±Ø§Øª Ù†Ù‚Ù„",
        "Ø´Ø§Ø­Ù†Ø§Øª Ù…ÙŠØ§Ù‡ ØµØ§Ù„Ø­Ø© Ù„Ù„Ø´Ø±Ø¨",
        "ğŸš‘ Ø³ÙŠØ§Ø±Ø§Øª Ø§Ø³Ø¹Ø§Ù",
    ],
    "ğŸ“š Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©": [
        "ğŸ“š ØªÙ…Ù‡ÙŠØ¯ÙŠ",
        "ğŸ“š Ø§Ø¹Ø¯Ø§Ø¯ÙŠ",
        "ğŸ“š Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯",
        "ğŸ“š Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ"
    ],
    # This category acts as a direct service (no inner subcategories). Selecting
    # it should immediately start the usual client/worker flow for that service.
    "ğŸ’ˆ Ø­Ù„Ø§Ù‚ØªÙƒ ÙÙŠ Ø­ÙˆØ´Ùƒ": [],
    "ğŸ“¸ ØªÙ†Ø³ÙŠÙ‚ Ø­Ø¯Ø§Ø¦Ù‚ ÙˆØªØµÙˆÙŠØ±": [
        "ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø­Ø¯Ø§Ø¦Ù‚",
        "ØªØµÙˆÙŠØ± Ù…Ù†Ø§Ø³Ø¨Ø§Øª",
        "Ø£Ø®Ø±Ù‰",
    ],
}

# flat list for legacy checks
WORK_TYPES = []
for lst in SERVICE_CATEGORIES.values():
    WORK_TYPES.extend(lst)

# Ensure any category-internal services exist in the flat WORK_TYPES list so
# existing membership checks continue to work.
for _cat, svc_list in SERVICE_CATEGORIES.items():
    for s in svc_list:
        if s not in WORK_TYPES:
            WORK_TYPES.append(s)

# add explicit direct-service labels that map from empty categories (e.g. the
# haircut category) so the code treating a selected service works without
# forcing the user to press an extra button. Keep emojis before text.
for extra in ("ğŸ’ˆ Ø­Ù„Ø§Ù‚ØªÙƒ ÙÙŠ Ø­ÙˆØ´Ùƒ", "ğŸ“š Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©"):
    if extra not in WORK_TYPES:
        WORK_TYPES.append(extra)

SERVICE_KEYS = {"Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "ğŸ› ï¸ Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "Ø§Ù„Ø®Ø¯Ù…Ø©", "Ø®Ø¯Ù…Ø§Øª", "Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "Ø³ÙŠØ±ÙØ²", "Ø³Ø±ÙØ²"}
CONTACT_KEYS = {"ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§", "Ø§ØªØµÙ„ Ø¨Ù†Ø§", "ØªÙˆØ§ØµÙ„", "Ø§ØªØµÙ„", "ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"}
ABOUT_KEYS = {"Ù†Ø¨Ø°Ø© Ø¹Ù†Ø§", "ğŸ“œ Ù†Ø¨Ø°Ø© Ø¹Ù†Ø§", "ğŸ“œÙ†Ø¨Ø°Ø© Ø¹Ù†Ø§", "Ù†Ø¨Ø°Ø©", "Ø¹Ù† Ø§Ù„ØªØ·Ø¨ÙŠÙ‚", "Ù…Ù† Ù†Ø­Ù†"}

# Education service aliases (support old and new labelled buttons)
# include variants with emoji before text and without so handlers match either label
EDUCATION_SERVICE_ALIASES = {
    "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©",
    "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ© ğŸ“š",
    "ğŸ“š Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©",
    # include the specific sub-buttons we show under the education category
    "ğŸ“š Ø§Ø¹Ø¯Ø§Ø¯ÙŠ",
    "ğŸ“š ØªÙ…Ù‡ÙŠØ¯ÙŠ",
    "ğŸ“š Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ",
    "ğŸ“š Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯",
    # also include non-emoji variants to be robust
    "Ø§Ø¹Ø¯Ø§Ø¯ÙŠ",
    "ØªÙ…Ù‡ÙŠØ¯ÙŠ",
    "Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ",
    "Ø«Ø§Ù†ÙˆÙŠ Ø§Ùˆ Ù…Ø¹Ù‡Ø¯",
}

# Main persistent keyboard used across client interactions. Use this single instance
# so all entry points present the same buttons and avoid disappearing rows.
MAIN_MENU_LAYOUT = [["ğŸ› ï¸ Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "ğŸ“ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†"], ["ğŸ”“ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", "ğŸ“ŠØ­Ø³Ø§Ø¨ÙŠ"], ["ğŸ“œ Ù†Ø¨Ø°Ø© Ø¹Ù†Ø§", "ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"]]

MAIN_KB = ReplyKeyboardMarkup(MAIN_MENU_LAYOUT, resize_keyboard=True)

# Helper to create reply keyboards that include a 'Ø§Ù„Ø±Ø¬ÙˆØ¹' back button by default.
def make_reply_kb(rows, one_time=False):
    try:
        # make a shallow copy to avoid mutating caller's list
        rows_copy = [list(r) for r in rows]
        if not rows_copy or rows_copy[-1] != ["Ø§Ù„Ø±Ø¬ÙˆØ¹"]:
            rows_copy.append(["Ø§Ù„Ø±Ø¬ÙˆØ¹"])
        return ReplyKeyboardMarkup(rows_copy, resize_keyboard=True, one_time_keyboard=one_time)
    except Exception:
        # fallback to the plain keyboard if anything goes wrong
        return ReplyKeyboardMarkup(rows, resize_keyboard=True, one_time_keyboard=one_time)

user_states = {}
workers = {}
# background tasks started by the process (so we can cancel them on shutdown)
BG_TASKS = []

DB_PATH = os.path.join(os.path.dirname(__file__), "data.db")
LOCKFILE = os.path.join(os.path.dirname(__file__), "bot.lock")

# Windows event loop policy (suppress DeprecationWarning when calling)
import sys, asyncio
import warnings
# ÙÙ‚Ø· Ø§Ø¶Ø¨Ø· Ø³ÙŠØ§Ø³Ø© Ø§Ù„Ø­Ù„Ù‚Ø© Ø¹Ù„Ù‰ ÙˆÙŠÙ†Ø¯ÙˆØ² Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù†Ø³Ø®Ø© Ø¨Ø§ÙŠØ«ÙˆÙ† Ø£Ù‚Ù„ Ù…Ù† 3.16
if sys.platform.startswith("win"):
    try:
        if sys.version_info < (3, 16) and hasattr(asyncio, "WindowsSelectorEventLoopPolicy"):
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", category=DeprecationWarning, message=".*WindowsSelectorEventLoopPolicy.*")
                warnings.filterwarnings("ignore", category=DeprecationWarning, message=".*set_event_loop_policy.*")
                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    except Exception:
        pass

# ---------- DB init ----------
def add_column_if_not_exists(conn, table, column_def):
    """column_def example: 'appearance_count INTEGER DEFAULT 0'"""
    colname = column_def.split()[0]
    cur = conn.cursor()
    cur.execute(f"PRAGMA table_info({table})")
    cols = [r[1] for r in cur.fetchall()]
    if colname not in cols:
        cur.execute(f"ALTER TABLE {table} ADD COLUMN {column_def}")
        conn.commit()

def init_db():
    try:
        logging.info("Init DB -> %s", DB_PATH)
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()

        cur.execute("""
        CREATE TABLE IF NOT EXISTS workers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER UNIQUE,
            name TEXT,
            phone TEXT,
            work_type TEXT,
            lat REAL,
            lon REAL,
            worker_code INTEGER,
            coupon_code TEXT,
            subscription_level INTEGER DEFAULT 0,
            subscription_expiry TIMESTAMP
        )
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            name TEXT,
            phone TEXT,
            service TEXT,
            lat REAL,
            lon REAL,
            assigned_worker_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS coupons (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE,
            amount INTEGER,
            used INTEGER DEFAULT 0,
            used_by_worker_user_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            used_at TIMESTAMP
        )
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS ratings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            worker_user_id INTEGER,
            client_user_id INTEGER,
            rating INTEGER,
            comment TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)

        # usage_stats table to track total users/requests
        cur.execute("""
        CREATE TABLE IF NOT EXISTS usage_stats (
            id INTEGER PRIMARY KEY CHECK (id = 1),
            total_users INTEGER DEFAULT 0,
            total_requests INTEGER DEFAULT 0
        )
        """)
        cur.execute("INSERT OR IGNORE INTO usage_stats (id, total_users, total_requests) VALUES (1,0,0)")

        # table to track if we've greeted a user before (so first-time users get the full menu)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS seen_users (
            user_id INTEGER PRIMARY KEY,
            first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)

        conn.commit()

        # Ensure counter columns exist on workers (safe migration)
        try:
            add_column_if_not_exists(conn, "workers", "appearance_count INTEGER DEFAULT 0")
            add_column_if_not_exists(conn, "workers", "ratings_received INTEGER DEFAULT 0")
            add_column_if_not_exists(conn, "workers", "selected_count INTEGER DEFAULT 0")
            # new column to record education service subtype for workers who register under educational services
            add_column_if_not_exists(conn, "workers", "education_type TEXT")
            # new column to record vehicle type for workers who register under vehicle-related services
            add_column_if_not_exists(conn, "workers", "vehicle_type TEXT")
            # new column to record the teacher's specialization within educational services
            add_column_if_not_exists(conn, "workers", "education_specialization TEXT")
            # new column to record company name for certain workers (e.g., ÙÙ†ÙŠ Ø§Ù†ØªØ±Ù†Øª)
            add_column_if_not_exists(conn, "workers", "company_name TEXT")
            # new column to mark the special service "Ø­Ù„Ø§Ù‚ØªÙƒ ÙÙŠ Ø­ÙˆØ´Ùƒ"
            add_column_if_not_exists(conn, "workers", "halakat_hoosh TEXT")
            # new column to record a general work specialization (e.g., for 'Ø£Ø±Ø¶ÙŠØ§Øª')
            add_column_if_not_exists(conn, "workers", "work_specialization TEXT")
        except Exception:
            logging.exception("Failed adding counter columns")

        conn.commit()
        conn.close()
        logging.info("Database initialized / migrated successfully.")
    except Exception:
        logging.exception("init_db error")

# ---------- Counters / stats helpers ----------
def increment_worker_appearance(worker_user_id, by=1):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("UPDATE workers SET appearance_count = COALESCE(appearance_count,0) + ? WHERE user_id = ?", (by, worker_user_id))
        conn.commit()
    finally:
        conn.close()

def increment_worker_selected(worker_user_id, by=1):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("UPDATE workers SET selected_count = COALESCE(selected_count,0) + ? WHERE user_id = ?", (by, worker_user_id))
        conn.commit()
    finally:
        conn.close()

def increment_worker_ratings(worker_user_id, by=1):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("UPDATE workers SET ratings_received = COALESCE(ratings_received,0) + ? WHERE user_id = ?", (by, worker_user_id))
        conn.commit()
    finally:
        conn.close()

def increment_usage_on_request(user_id):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        # Ø§Ø°Ø§ Ù‡Ø°Ù‡ Ø£ÙˆÙ„ Ù…Ø±Ø© ÙŠØ·Ù„Ø¨ ÙÙŠÙ‡Ø§ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø²ÙØ¯Ù‘ total_users
        cur.execute("SELECT COUNT(*) FROM clients WHERE user_id = ?", (user_id,))
        prior = cur.fetchone()[0] or 0
        if prior == 0:
            cur.execute("UPDATE usage_stats SET total_users = COALESCE(total_users,0) + 1 WHERE id = 1")
        # Ø¯ÙˆÙ‘Ù† Ø§Ù„Ø·Ù„Ø¨ ÙƒÙ€ total_requests
        cur.execute("UPDATE usage_stats SET total_requests = COALESCE(total_requests,0) + 1 WHERE id = 1")
        conn.commit()
    finally:
        conn.close()

# ---------- DB helpers (single copy) ----------
def fetch_worker_by_code(code):
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT id, user_id, name, phone, work_type, lat, lon, subscription_level, subscription_expiry, worker_code, education_type, education_specialization, vehicle_type, company_name, halakat_hoosh, work_specialization, appearance_count, ratings_received, selected_count FROM workers WHERE worker_code = ?", (code,))
        r = cur.fetchone()
        conn.close()
        if not r:
            return None
        return {
            "id": r[0],
            "user_id": r[1],
            "name": r[2],
            "phone": r[3],
            "work_type": r[4],
            "location": (r[5], r[6]),
            "subscription_level": r[7],
            "subscription_expiry": r[8],
            "worker_code": r[9],
            "education_type": r[10],
            "education_specialization": r[11],
            "vehicle_type": r[12],
            "company_name": r[13],
            "halakat_hoosh": r[14],
            "work_specialization": r[15],
            "appearance_count": r[16] or 0,
            "ratings_received": r[17] or 0,
            "selected_count": r[18] or 0
        }
    except Exception:
        logging.exception("fetch_worker_by_code failed")
        return None


def save_worker_to_db(user_id, state):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    lat, lon = state.get("location", (None, None))
    cur.execute("SELECT id, worker_code FROM workers WHERE user_id = ?", (user_id,))
    existing = cur.fetchone()
    if existing:
        row_id, worker_code = existing
    cur.execute("UPDATE workers SET name = ?, phone = ?, work_type = ?, lat = ?, lon = ?, education_type = ?, education_specialization = ?, vehicle_type = ?, company_name = ?, halakat_hoosh = ?, work_specialization = ? WHERE user_id = ?",
        (state.get("name"), state.get("phone"), state.get("work_type"), lat, lon, state.get("edu_type"), state.get("edu_specialization"), state.get("vehicle_type"), state.get("company_name"), state.get("halakat_hoosh"), state.get("work_specialization"), user_id))
        # apply subscription fields if present in state
    if state.get("subscription_level") or state.get("subscription_expiry") or state.get("coupon_code"):
        try:
            cur.execute("UPDATE workers SET subscription_level = ?, subscription_expiry = ?, coupon_code = ? WHERE user_id = ?",
                        (state.get("subscription_level"), state.get("subscription_expiry"), state.get("coupon_code"), user_id))
        except Exception:
            logging.debug("Could not update subscription fields for existing worker")
    if existing and not worker_code:
        worker_code = 2000 + existing[0]
        try:
            cur.execute("UPDATE workers SET worker_code = ? WHERE id = ?", (worker_code, existing[0]))
        except Exception:
            pass
    conn.commit()
    if existing:
        conn.close()
        return worker_code
    cur.execute("INSERT INTO workers (user_id, name, phone, work_type, lat, lon, education_type, education_specialization, vehicle_type, company_name, halakat_hoosh, work_specialization) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (user_id, state.get("name"), state.get("phone"), state.get("work_type"), lat, lon, state.get("edu_type"), state.get("edu_specialization"), state.get("vehicle_type"), state.get("company_name"), state.get("halakat_hoosh"), state.get("work_specialization")))
    conn.commit()
    rowid = cur.lastrowid
    worker_code = 2000 + rowid
    try:
        cur.execute("UPDATE workers SET worker_code = ? WHERE id = ?", (worker_code, rowid))
        conn.commit()
    except Exception:
        pass
    # Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø±Ø§Ø¬ØŒ Ø·Ø¨Ù‚ Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¥Ù† ÙˆÙØ¬Ø¯Øª
    try:
        if state.get("subscription_level") or state.get("subscription_expiry") or state.get("coupon_code"):
            cur.execute("UPDATE workers SET subscription_level = ?, subscription_expiry = ?, coupon_code = ? WHERE id = ?",
                        (state.get("subscription_level"), state.get("subscription_expiry"), state.get("coupon_code"), rowid))
            conn.commit()
    except Exception:
        logging.debug("Could not set subscription fields for new worker")
    conn.close()
    return worker_code


def save_client_request_to_db(user_id, state, req_id=None):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    lat, lon = state.get("location", (None, None))
    name = state.get("name")
    phone = state.get("phone")
    service = state.get("service")
    if req_id:
        cur.execute("UPDATE clients SET user_id=?, name=?, phone=?, service=?, lat=?, lon=?, created_at=CURRENT_TIMESTAMP WHERE id=?",
                    (user_id, name, phone, service, lat, lon, req_id))
        conn.commit()
        cid = req_id
    else:
        cur.execute("INSERT INTO clients (user_id, name, phone, service, lat, lon) VALUES (?,?,?,?,?,?)",
                    (user_id, name, phone, service, lat, lon))
        conn.commit()
        cid = cur.lastrowid
        # ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯
        try:
            increment_usage_on_request(user_id)
        except Exception:
            logging.exception("Failed to increment usage stats")
    conn.close()
    return cid


def mark_user_seen(user_id):
    """Return True if this is the first time we've seen this user (inserted), False otherwise."""
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT 1 FROM seen_users WHERE user_id = ?", (user_id,))
        if cur.fetchone():
            conn.close(); return False
        cur.execute("INSERT INTO seen_users (user_id) VALUES (?)", (user_id,))
        conn.commit(); conn.close(); return True
    except Exception:
        try:
            conn.close()
        except Exception:
            pass
        return False

def save_rating_to_db(worker_user_id, client_user_id, rating, comment=None):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("INSERT INTO ratings (worker_user_id, client_user_id, rating, comment) VALUES (?,?,?,?)",
                    (worker_user_id, client_user_id, int(rating), comment))
        conn.commit()
        # Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª Ù„Ù„Ø¹Ø§Ù…Ù„
        try:
            increment_worker_ratings(worker_user_id, by=1)
        except Exception:
            logging.exception("Failed to increment worker ratings counter")
    finally:
        conn.close()

# ---------- Bot handlers ----------
async def redeem_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_states[user_id] = {"role": "redeem", "step": "code"}
    await update.message.reply_text("Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø´Ø­Ù† (Ø§Ù„ÙƒÙˆØ¨ÙˆÙ†) Ù„ØªÙØ¹ÙŠÙ„Ù‡:")

# New helper: redeem and apply coupon to a worker (target_worker_user_id)
def redeem_coupon_for_worker(code_input, requesting_user_id, target_worker_user_id=None, desired_tier=None):
    """Try to redeem coupon and apply subscription to target worker. Returns (ok:bool, msg:str)."""
    if not code_input:
        return False, "ÙƒÙˆØ¯ ØºÙŠØ± ØµØ§Ù„Ø­."
    raw = re.sub(r"[^\w\-]", "", code_input.strip().upper())
    raw_nz = re.sub(r"^0+", "", raw)
    candidates = []
    for cand in (raw, raw_nz):
        if cand:
            candidates.append(cand)
            if not cand.startswith("VIP-"):
                candidates.append("VIP-" + cand)
    seen = []
    candidates = [c for c in candidates if c and (c not in seen and not seen.append(c))]

    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        found = None
        for c in candidates:
            cur.execute("SELECT id, amount, used, code FROM coupons WHERE UPPER(code) = ?", (c.upper(),))
            row = cur.fetchone()
            if row:
                found = row
                break
        if not found:
            conn.close()
            return False, "Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØºÙŠØ± ØµØ§Ù„Ø­."
        cid, amount, used, actual_code = found
        if used:
            conn.close()
            return False, "Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…ÙØ³ØªØ®Ø¯Ù… Ù…Ø³Ø¨Ù‚Ø§Ù‹."

        # Determine desired tier if not provided: default to code amount mapping
        if desired_tier:
            if desired_tier == "gold" and int(amount) != 100:
                conn.close(); return False, "Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù„ÙŠØ³ Ù…Ø®ØµØµÙ‹Ø§ Ù„Ù„ÙØ¦Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©. Ø§Ø³ØªØ®Ø¯Ù… ÙƒÙˆØ¯Ù‹Ø§ Ø¨Ù‚ÙŠÙ…Ø© 100 Ø¯.Ù„."
            if desired_tier == "silver" and int(amount) != 60:
                conn.close(); return False, "Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù„ÙŠØ³ Ù…Ø®ØµØµÙ‹Ø§ Ù„Ù„ÙØ¦Ø© Ø§Ù„ÙØ¶ÙŠØ©. Ø§Ø³ØªØ®Ø¯Ù… ÙƒÙˆØ¯Ù‹Ø§ Ø¨Ù‚ÙŠÙ…Ø© 60 Ø¯.Ù„."
        else:
            # infer
            if int(amount) == 100:
                desired_tier = "gold"
            elif int(amount) == 60:
                desired_tier = "silver"
            else:
                desired_tier = "custom"

        if desired_tier == "gold":
            level = 1; days = 32; tier_name = "Ø°Ù‡Ø¨ÙŠ"
        elif desired_tier == "silver":
            level = 2; days = 30; tier_name = "ÙØ¶ÙŠ"
        else:
            level = 0; days = 30; tier_name = f"({amount})"

        expiry = datetime.utcnow() + timedelta(days=days)
        expiry_iso = expiry.isoformat()

        # choose target worker
        if not target_worker_user_id:
            target_worker_user_id = requesting_user_id

        # mark coupon used and update worker
        try:
            cur.execute("UPDATE coupons SET used=1, used_by_worker_user_id=?, used_at=? WHERE id=?", (target_worker_user_id, expiry_iso, cid))
            cur.execute("UPDATE workers SET subscription_level = ?, subscription_expiry = ?, coupon_code = ? WHERE user_id = ?",
                        (level, expiry_iso, actual_code, target_worker_user_id))
            conn.commit()
            conn.close()
            return True, f"ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„ÙØ¦Ø© {tier_name}. Ø³ÙŠÙ†ØªÙ‡ÙŠ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨ØªØ§Ø±ÙŠØ® {expiry_iso}."
        except Exception:
            conn.close()
            logging.exception("Error while marking coupon used in redeem_coupon_for_worker")
            return False, "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙƒÙˆØ¯. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…."
    except Exception:
        logging.exception("redeem_coupon_for_worker failed")
        return False, "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙˆØ¯."

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_states.pop(user_id, None)
    await update.message.reply_text("Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨ÙƒÙ… ÙÙŠ Ø¨ÙˆØª Ø®Ø¯Ù…ØªÙŠ", reply_markup=MAIN_KB)

async def send_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else None
    if not ADMIN_ID or uid != ADMIN_ID:
        await update.message.reply_text("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.")
        return
    try:
        subs = fetch_subscribers()
        sub_count = len(subs)
        conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM workers"); workers_count = cur.fetchone()[0] or 0
        cur.execute("SELECT id, name, phone, work_type, worker_code, subscription_level, subscription_expiry FROM workers ORDER BY id DESC LIMIT 1000"); wrows = cur.fetchall()
        conn.close()
    except Exception:
        logging.exception("send_admin_panel failed")
        await update.message.reply_text("ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.")
        return

    header = f"Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\nØ§Ù„Ù…Ø´ØªØ±ÙƒÙˆÙ†: {sub_count}\nØ§Ù„Ø¹Ù…Ø§Ù„: {workers_count}\n\n"
    sub_lines = [f"{s['id']} | {s['name'] or '-'} | {s['phone'] or '-'}" for s in subs]
    subs_text = "Ø§Ù„Ù…Ø´ØªØ±ÙƒÙˆÙ† (Ø¢Ø®Ø±):\n" + ("\n".join(sub_lines) if sub_lines else "(Ù„Ø§ Ø³Ø¬Ù„Ø§Øª)")
    w_lines = [f"{wid} | {name or '-'} | {phone or '-'} | {wtype or '-'} | code:{wcode or '-'} | lvl:{level or 0} | exp:{expiry or '-'}" for wid, name, phone, wtype, wcode, level, expiry in wrows]
    workers_text = "Ø§Ù„Ø¹Ù…Ø§Ù„ (Ø¢Ø®Ø±):\n" + ("\n".join(w_lines) if w_lines else "(Ù„Ø§ Ø³Ø¬Ù„Ø§Øª)")
    OUT_LIMIT = 3500
    await update.message.reply_text(header)
    if len(subs_text) > OUT_LIMIT:
        from io import BytesIO
        bio = BytesIO(subs_text.encode("utf-8")); bio.name = "subscribers.txt"
        await update.message.reply_document(bio)
    else:
        await update.message.reply_text(subs_text)
    if len(workers_text) > OUT_LIMIT:
        from io import BytesIO
        bio = BytesIO(workers_text.encode("utf-8")); bio.name = "workers.txt"
        await update.message.reply_document(bio)
    else:
        await update.message.reply_text(workers_text)

# New: compute average rating for a worker
def fetch_rating_stats(worker_user_id):
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*), COALESCE(AVG(rating),0) FROM ratings WHERE worker_user_id = ?", (worker_user_id,))
        cnt, avg = cur.fetchone()
        conn.close()
        return (cnt or 0, float(avg or 0))
    except Exception:
        logging.exception("fetch_rating_stats failed")
        return (0, 0.0)


def fetch_worker_by_userid(user_id):
    """Return worker dict by Telegram user_id or None."""
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT id, user_id, name, phone, work_type, lat, lon, subscription_level, subscription_expiry, worker_code, education_type, education_specialization, vehicle_type, company_name, halakat_hoosh, appearance_count, ratings_received, selected_count FROM workers WHERE user_id = ?", (user_id,))
        cur.execute("SELECT id, user_id, name, phone, work_type, lat, lon, subscription_level, subscription_expiry, worker_code, education_type, education_specialization, vehicle_type, company_name, halakat_hoosh, work_specialization, appearance_count, ratings_received, selected_count FROM workers WHERE user_id = ?", (user_id,))
        r = cur.fetchone()
        conn.close()
        if not r:
            return None
        return {
            "id": r[0],
            "user_id": r[1],
            "name": r[2],
            "phone": r[3],
            "work_type": r[4],
            "location": (r[5], r[6]),
            "subscription_level": r[7],
            "subscription_expiry": r[8],
            "worker_code": r[9],
            "education_type": r[10],
            "education_specialization": r[11],
            "vehicle_type": r[12],
            "company_name": r[13],
            "halakat_hoosh": r[14],
            "work_specialization": r[15],
            "appearance_count": r[16] or 0,
            "ratings_received": r[17] or 0,
            "selected_count": r[18] or 0
        }
    except Exception:
        logging.exception("fetch_worker_by_userid failed")
        return None

# ---------- Bot handlers (continued) ----------
async def handle_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.message.from_user.id if update.message and update.message.from_user else None
        # greet first-time users with the full main keyboard so anyone who opens the bot
        # immediately sees the available options.
        try:
            if user_id:
                if mark_user_seen(user_id):
                    try:
                        await update.message.reply_text("Ù…Ø±Ø­Ø¨Ù‹Ø§! Ø¥Ù„ÙŠÙƒ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=MAIN_KB)
                    except Exception:
                        logging.debug("Could not send first-time welcome keyboard to user %s", user_id)
        except Exception:
            logging.debug("mark_user_seen failed for user %s", user_id)
        text_orig = ""
        contact_obj = None
        if update.message:
            contact_obj = getattr(update.message, "contact", None)
            if contact_obj and getattr(contact_obj, "phone_number", None):
                text_orig = contact_obj.phone_number
            elif update.message.text:
                text_orig = update.message.text
        logging.info("RAW_MSG repr: %r ; contact=%r ; from=%s", text_orig, contact_obj, user_id)
        text = text_orig.strip()
        text_l = text.lower()
        # Temporary debug logging to capture button presses and current state
        try:
            logging.info("BUTTON_DEBUG user=%s text=%r state=%r", user_id, text, user_states.get(user_id))
        except Exception:
            logging.debug("Failed to log BUTTON_DEBUG")
        # Self-stat shortcut: if a worker sends '1' show their own stats (only for the same user_id)
        if text.strip() == "1":
            try:
                w = fetch_worker_by_userid(user_id)
                if not w:
                    await update.message.reply_text("Ø£Ù†Øª Ù„Ø³Øª Ù…Ø³Ø¬Ù„Ø§Ù‹ ÙƒØ¹Ø§Ù…Ù„ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù….")
                    return
                # fetch rating count and average
                cnt, avg = fetch_rating_stats(user_id)
                appearance = w.get("appearance_count", 0) or 0
                selected = w.get("selected_count", 0) or 0
                msg = (
                    f"Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø­Ø³Ø§Ø¨Ùƒ:\n"
                    f"Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: {avg:.2f} (Ù…Ù† {cnt} ØªÙ‚ÙŠÙŠÙ…)\n"
                    f"Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø¸Ù‡ÙˆØ±: {appearance}\n"
                    f"Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±: {selected}"
                )
                await update.message.reply_text(msg)
            except Exception:
                logging.exception("self-stats (1) handler failed")
            return
        # admin shortcuts
        if "conf" in text_l:
            await send_admin_panel(update, context); return
        # send-to-all shortcut: when admin types `sta` anywhere, start broadcast flow
        if "sta" in text_l:
            uid = update.effective_user.id if update.effective_user else None
            if not ADMIN_ID or uid != ADMIN_ID:
                await update.message.reply_text("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© ØªÙ†ÙÙŠØ° Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±.")
                return
            user_states[uid] = {"role": "broadcast", "step": "compose"}
            await update.message.reply_text("Ø£Ø±Ø³Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø±ÙÙŠÙŠÙ† Ø£Ùˆ Ù‚Ù… Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ¬ÙŠÙ‡Ù‡Ø§ (forward) Ø¥Ù„ÙŠÙ‡Ù…:")
            return
        if text_l in CONTACT_KEYS:
            phone_local = "0916564000"; phone_international = "+218916564000"; wa_number = "218916564000"
            try:
                await update.message.reply_contact(phone_number=phone_international, first_name="ÙØ±ÙŠÙ‚ Ø§Ù„Ø¯Ø¹Ù…")
            except Exception:
                logging.debug("reply_contact failed")
            wa_btn = InlineKeyboardMarkup([[InlineKeyboardButton("Ù…Ø±Ø§Ø³Ù„ØªÙ†Ø§ Ø¹Ø¨Ø± ÙˆØ§ØªØ³Ø§Ø¨", url=f"https://wa.me/{wa_number}")]] )
            # include phone number with phone emoji in the reply
            await update.message.reply_text(f"ğŸ“ Ù„Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ù‡Ğ°Ñ‚ÙÙŠ: {phone_local}\n\nÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ù‹Ø§ Ù…Ø±Ø§Ø³Ù„ØªÙ†Ø§ Ø¹Ø¨Ø± ÙˆØ§ØªØ³Ø§Ø¨:", reply_markup=wa_btn)
            return
        # Ø­Ø³Ø§Ø¨ÙŠ flow: worker enters their code to view account stats
        # be permissive: match any message containing the word 'Ø­Ø³Ø§Ø¨ÙŠ' (with or without emoji/space)
        try:
            if (isinstance(text, str) and "Ø­Ø³Ø§Ø¨ÙŠ" in text) or (isinstance(text_l, str) and "Ø­Ø³Ø§Ø¨ÙŠ" in text_l):
                user_states[user_id] = {"role": "view_my_account", "step": "enter_code"}
                await update.message.reply_text("Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù (code) Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø­Ø³Ø§Ø¨Ùƒ:", reply_markup=ReplyKeyboardRemove())
                return
        except Exception:
            # fallback to previous explicit matches if something unexpected happens
            if text in ("Ø­Ø³Ø§Ø¨ÙŠ", "Ø­Ø³Ø§Ø¨ÙŠğŸ“Š", "Ø­Ø³Ø§Ø¨ÙŠ ğŸ“Š"):
                user_states[user_id] = {"role": "view_my_account", "step": "enter_code"}
                await update.message.reply_text("Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù (code) Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø­Ø³Ø§Ø¨Ùƒ:", reply_markup=ReplyKeyboardRemove())
                return
        if text_l in ABOUT_KEYS:
            about_text = (
                "Ø¨ÙˆØª Ø®Ø¯Ù…ØªÙŠ | ØªØ£Ø³Ø³ Ø¹Ø§Ù… 2025\n\n"
                "Ù†Ø­Ù† Ø¨ÙˆØª ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ÙŠÙ‡Ø¯Ù Ø¥Ù„Ù‰ ØªØ³Ù‡ÙŠÙ„ Ø·Ù„Ø¨ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙˆØ§Ù„Ø­Ø±ÙÙŠÙŠÙ†.\n"
                "ÙƒÙ„ Ù…Ø§ Ø¹Ù„ÙŠÙƒ Ù‡Ùˆ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ø«Ù… Ø¥Ø±Ø³Ø§Ù„ Ù…ÙˆÙ‚Ø¹ÙƒØŒ ÙˆØ³ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ø§Ù„Ø¨ÙˆØª Ø£Ù‚Ø±Ø¨ Ø­Ø±ÙÙŠ Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙˆØ§ØµÙ„.\n\n"
                "âœ… Ø§Ù„Ø®Ø¯Ù…Ø© Ù…Ø¬Ø§Ù†ÙŠØ© ØªÙ…Ø§Ù…Ù‹Ø§ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡\n"
                "ğŸ’¼ ÙˆØ§Ø´ØªØ±Ø§Ùƒ Ø±Ù…Ø²ÙŠ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†\n\n"
                "Ù„Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø± Ø£Ùˆ Ø¯Ø¹Ù…ØŒ Ù„Ø§ ØªØªØ±Ø¯Ø¯ ÙÙŠ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ ğŸ’¬"
            )
            await update.message.reply_text(about_text, reply_markup=ReplyKeyboardRemove())
            await update.message.reply_text("Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=MAIN_KB)
            return

        # If user types "Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡" inform them registration removed
        if text_l == "Ø§Ù„ØªØ¬ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡":
            name = None
            if update.effective_user:
                fn = update.effective_user.first_name or ""; ln = update.effective_user.last_name or ""; name = (fn + " " + ln).strip() or None
            contact = getattr(update.message, "contact", None)
            phone = contact.phone_number if contact and getattr(contact, "phone_number", None) else None
            user_states[user_id] = {"role": "subscriber", "step": ("location" if phone else "phone"), "name": name, "phone": phone}
            if phone:
                kb = make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])
                await update.message.reply_text(f"ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³Ù… Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
            else:
                kb = make_reply_kb([[KeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„", request_contact=True)]])
                await update.message.reply_text(f"Ø³ÙŠÙØ³ØªØ®Ø¯Ù… Ø§Ø³Ù… Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø¨Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:", reply_markup=kb)
            return
        if text_l in ("Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†", "ğŸ“ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†"):
            user_states[user_id] = {"role": "worker", "step": "name"}
            await update.message.reply_text("Ø³Ø¬Ù„ ÙƒØ¹Ø§Ù…Ù„ - ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù…Ùƒ:")
            return

        # Activation flow entrance (button in main menu)
        if text_l == "ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ":
            user_states[user_id] = {"role": "activate_subscription", "step": "enter_worker_code"}
            await update.message.reply_text("Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ (worker code) Ù„ØªÙØ¹ÙŠÙ„ Ø£Ùˆ ØªØ¬Ø¯ÙŠØ¯ Ø§Ø´ØªØ±Ø§ÙƒÙƒ:")
            return

        if text_l in SERVICE_KEYS:
            # show top-level categories
            cats = list(SERVICE_CATEGORIES.keys())
            kb = make_reply_kb([[c] for c in cats])
            # record browsing state so back button can return to previous menu
            user_states[user_id] = {"role": "browsing", "step": "categories"}
            await update.message.reply_text("Ø§Ø®ØªØ± Ø§Ù„ÙØ¦Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªØµÙØ­ Ø®Ø¯Ù…Ø§ØªÙ‡Ø§:", reply_markup=kb)
            return
        # If user selected a category name, either show its services or treat the
        # category as a direct service (when its services list is empty). This
        # enables categories like the haircut section to immediately start the
        # usual client/worker flow.
        if text in SERVICE_CATEGORIES:
            services = SERVICE_CATEGORIES.get(text) or []
            if services:
                kb_rows = [[s] for s in services]
                kb = make_reply_kb(kb_rows)
                # remember which category we're browsing
                user_states[user_id] = {"role": "browsing", "step": "services", "category": text}
                await update.message.reply_text(f"Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ù…Ù† ÙØ¦Ø©: {text}", reply_markup=kb)
                return
            else:
                # map empty-category to a canonical service label so the
                # following `if text in WORK_TYPES` block will handle it like a
                # normal service selection. Keep emojis-first labels.
                category_to_service = {
                    "ğŸ’ˆ Ø­Ù„Ø§Ù‚ØªÙƒ ÙÙŠ Ø­ÙˆØ´Ùƒ": "ğŸ’ˆ Ø­Ù„Ø§Ù‚ØªÙƒ ÙÙŠ Ø­ÙˆØ´Ùƒ",
                    "ğŸ“š Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©": "ğŸ“š Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©",
                }
                mapped = category_to_service.get(text)
                if mapped:
                    # update text so execution continues to the service branch
                    text = mapped
                    # since this category maps directly to a service (empty
                    # sub-list), set browsing state to 'services' so the
                    # downstream handler treats this as a service selection
                    # coming from a category and proceeds to the client flow.
                    user_states[user_id] = {"role": "browsing", "step": "services", "category": mapped}
                else:
                    kb = make_reply_kb([["Ø§Ù„Ø±Ø¬ÙˆØ¹"]])
                    await update.message.reply_text("Ø§Ù„Ø±Ø¬ÙˆØ¹", reply_markup=kb)
                    return
        # If user pressed a generic back/return button, try to return to the
        # previous menu based on the stored browsing state. Fall back to main
        # menu if no previous state is available.
        if text in ("Ø§Ù„Ø±Ø¬ÙˆØ¹", "Ø¹ÙˆØ¯Ø©", "Ø¹ÙˆØ¯Ø© Ù„Ù„Ø®Ø¯Ù…Ø§Øª", "Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ø®Ø¯Ù…Ø§Øª"):
            prev = user_states.get(user_id)
            if prev:
                # browsing flow: if we were in services list go back to categories
                if prev.get("role") == "browsing":
                    if prev.get("step") == "services":
                        cats = list(SERVICE_CATEGORIES.keys())
                        kb = make_reply_kb([[c] for c in cats])
                        user_states[user_id] = {"role": "browsing", "step": "categories"}
                        await update.message.reply_text("Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ ÙØ¦Ø§Øª Ø§Ù„Ø®Ø¯Ù…Ø§Øª:", reply_markup=kb)
                        return
                    if prev.get("step") == "categories":
                        # go back to main menu
                        user_states.pop(user_id, None)
                        await update.message.reply_text("Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=MAIN_KB)
                        return
                # if user was mid-flow (client/worker/subscriber), try a conservative
                # step-back: for client phone -> go back to service selection
                if prev.get("role") == "client":
                    # show categories again for convenience
                    cats = list(SERVICE_CATEGORIES.keys())
                    kb = make_reply_kb([[c] for c in cats])
                    user_states[user_id] = {"role": "browsing", "step": "categories"}
                    await update.message.reply_text("ØªÙ… Ø§Ù„Ø±Ø¬ÙˆØ¹. Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ù…Ù† Ø¬Ø¯ÙŠØ¯:", reply_markup=kb)
                    return
            # default: show main menu
            await update.message.reply_text("Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=MAIN_KB)
            return
        # If user selected a work/service type: allow selection both when the
        # user is not in any state (direct selection) or when they're browsing
        # services (from a category).
        curr_state = user_states.get(user_id)
        if text in WORK_TYPES and (user_id not in user_states or (curr_state and curr_state.get("role") == "browsing" and curr_state.get("step") == "services")):
            name = None
            if update.effective_user:
                fn = update.effective_user.first_name or ""; ln = update.effective_user.last_name or ""; name = (fn + " " + ln).strip() or None
            contact = getattr(update.message, "contact", None)
            phone = contact.phone_number if contact and getattr(contact, "phone_number", None) else None
            state = {"role": "client", "service": text, "name": name, "phone": phone}
            # clear browsing state since we're now in client request flow
            if curr_state and curr_state.get("role") == "browsing":
                user_states.pop(user_id, None)
            # If client selected an education subtype (one of the sub-buttons),
            # treat it as a normal service selection but record the requested
            # education division in state['edu_type'] so fetch_workers_by_service
            # can filter appropriately later.
            edu_subtypes = {"ğŸ“š Ø§Ø¹Ø¯Ø§Ø¯ÙŠ", "ğŸ“š ØªÙ…Ù‡ÙŠØ¯ÙŠ", "ğŸ“š Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ", "ğŸ“š Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯", "Ø§Ø¹Ø¯Ø§Ø¯ÙŠ", "ØªÙ…Ù‡ÙŠØ¯ÙŠ", "Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ", "Ø«Ø§Ù†ÙˆÙŠ Ø§Ùˆ Ù…Ø¹Ù‡Ø¯"}
            if text in edu_subtypes:
                # normalize by removing leading non-Arabic/letter chars (emoji)
                cleaned = re.sub(r"^[^\w\u0600-\u06FF]*", "", text).strip()
                state["edu_type"] = cleaned
                # proceed to the normal phone/location prompt below (no early return)
            if phone:
                state["step"] = "location"; user_states[user_id] = state
                kb = make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])
                await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {text}\nØ§Ù„Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø¢Ù† Ø´Ø§Ø±Ùƒ Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
            else:
                state["step"] = "phone"; user_states[user_id] = state
                kb = make_reply_kb([[KeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„", request_contact=True)]])
                await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {text}\nØ³ÙŠÙØ³ØªØ®Ø¯Ù… Ø§Ø³Ù… Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø¨Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:", reply_markup=kb)
            return
        if user_id in user_states:
            state = user_states[user_id]
            # broadcast flow (admin)
            if state.get("role") == "broadcast":
                if state.get("step") == "compose":
                    ids = fetch_all_workers_user_ids()
                    if not ids:
                        await update.message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙÙŠÙŠÙ† Ù…Ø³Ø¬Ù„ÙŠÙ† Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
                        user_states.pop(user_id, None)
                        return

                    sent = 0; failed = 0
                    # If admin replied to an existing message, forward that original message to workers
                    orig = update.message.reply_to_message if update.message and getattr(update.message, "reply_to_message", None) else None
                    # prefix/header that will be visible to recipients
                    header_label = "Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø®Ø¯Ù…ØªÙŠ Ù„ÙŠØ¨ÙŠØ§:"
                    if orig:
                        # Use copy_message instead of forward_message so the recipients do NOT see the original sender details
                        # send in batches to avoid hitting Telegram rate limits
                        for i in range(0, len(ids), BROADCAST_BATCH_SIZE):
                            batch = ids[i:i+BROADCAST_BATCH_SIZE]
                            tasks = []
                            for wid in batch:
                                async def do_copy(target=wid):
                                    nonlocal sent, failed
                                    try:
                                        await context.bot.send_message(target, header_label)
                                        await context.bot.copy_message(chat_id=target, from_chat_id=orig.chat_id, message_id=orig.message_id)
                                        sent += 1
                                    except Exception:
                                        failed += 1
                                        logging.debug("Failed copying broadcast to %s", target)
                                tasks.append(asyncio.create_task(do_copy()))
                            # wait for batch to finish
                            if tasks:
                                await asyncio.gather(*tasks)
                            # delay between batches
                            await asyncio.sleep(BROADCAST_BATCH_DELAY)
                        await update.message.reply_text(f"ØªÙ…Øª Ø¥Ø±Ø³Ø§Ù„ Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {sent} Ø­Ø±ÙÙŠ(Ù€Ù‹Ø§). ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ {failed}.")
                        user_states.pop(user_id, None)
                        return

                    # Otherwise send the typed text as a private message to each worker
                    text_to_send = text_orig or ""
                    if not text_to_send:
                        await update.message.reply_text("Ø§Ù„Ù†Øµ ÙØ§Ø±Øº. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØµØ­ÙŠØ­Ø© Ø£Ùˆ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ¬ÙŠÙ‡Ù‡Ø§.")
                        return
                    # send text message with header combined
                    combined = f"Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø®Ø¯Ù…ØªÙŠ Ù„ÙŠØ¨ÙŠØ§:\n\n{text_to_send}"
                    # send in batches to avoid rate limits
                    for i in range(0, len(ids), BROADCAST_BATCH_SIZE):
                        batch = ids[i:i+BROADCAST_BATCH_SIZE]
                        tasks = []
                        for wid in batch:
                            async def do_send(target=wid, text=combined):
                                nonlocal sent, failed
                                try:
                                    await context.bot.send_message(target, text)
                                    sent += 1
                                except Exception:
                                    failed += 1
                                    logging.debug("Failed sending broadcast to %s", target)
                            tasks.append(asyncio.create_task(do_send()))
                        if tasks:
                            await asyncio.gather(*tasks)
                        await asyncio.sleep(BROADCAST_BATCH_DELAY)
                    await update.message.reply_text(f"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {sent} Ø­Ø±ÙÙŠ(Ù€Ù‹Ø§). ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ {failed}.")
                    user_states.pop(user_id, None)
                    return
            # Activation state handling
            if state.get("role") == "activate_subscription":
                if state.get("step") == "enter_worker_code":
                    if not text.isdigit():
                        await update.message.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù…Ø§Ù‹. Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ (Ù…Ø«Ù„ 2001):")
                        return
                    w = fetch_worker_by_code(int(text))
                    if not w:
                        await update.message.reply_text("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ø§Ù…Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù…. ØªØ£ÙƒØ¯ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                        return
                    # store target worker and ask to pick tier
                    state["target_user_id"] = w["user_id"]
                    state["step"] = "awaiting_tier_choice"
                    user_states[user_id] = state
                    sub_kb = InlineKeyboardMarkup([
                        [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ© â€” 100 Ø¯.Ù„", callback_data=f"pick_activate:gold:{w['user_id']}")],
                        [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ¶ÙŠØ© â€” 60 Ø¯.Ù„", callback_data=f"pick_activate:silver:{w['user_id']}")]
                    ])
                    await update.message.reply_text(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ø§Ù…Ù„: {w.get('name') or '-'}\nØ§Ø®ØªØ± Ø§Ù„ÙØ¦Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:", reply_markup=sub_kb)
                    return
                if state.get("step") == "awaiting_coupon":
                    code = text.strip()
                    ok, msg = redeem_coupon_for_worker(code, user_id, target_worker_user_id=state.get("target_user_id"), desired_tier=state.get("desired_tier"))
                    await update.message.reply_text(msg)
                    if ok:
                        # notify the target worker (best-effort)
                        try:
                            target_uid = state.get("target_user_id")
                            if target_uid:
                                try:
                                    await context.bot.send_message(target_uid, f"ğŸ‰ ØªÙ… ØªÙØ¹ÙŠÙ„ Ø£Ùˆ ØªØ¬Ø¯ÙŠØ¯ Ø§Ø´ØªØ±Ø§ÙƒÙƒ:\n{msg}")
                                except Exception:
                                    logging.debug("Could not notify worker %s about coupon activation", target_uid)
                        except Exception:
                            logging.exception("Error while notifying worker after coupon activation")
                        user_states.pop(user_id, None)
                    return
            # subscriber flow
            if state.get("role") == "subscriber":
                if state.get("step") == "name":
                    state["name"] = text; state["step"] = "phone"
                    await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:"); return
                if state.get("step") == "phone":
                    if not is_valid_phone(text):
                        await update.message.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø±Ø³Ù„Ù‡ Ø¨ØµÙŠØºØ© 091xxxxxxx Ø£Ùˆ 9xxxxxxx Ø£Ùˆ +2189xxxxxxx."); return
                    state["phone"] = normalize_phone(text); state["step"] = "location"
                    kb = make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])
                    await update.message.reply_text("Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹' Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb); return
            # client flow
            if state.get("role") == "client":
                if state.get("step") == "awaiting_request_id":
                    if text.isdigit():
                        req = fetch_client_request_by_id(int(text))
                        if req:
                            state["name"] = req.get("name"); state["phone"] = req.get("phone")
                            state["step"] = "location" if state.get("phone") else "phone"
                            await update.message.reply_text("ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨. Ø£Ø±Ø³Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ Ø£Ùˆ Ø§Ø¯Ø®Ù„ Ù‡Ø§ØªÙÙƒ:", reply_markup=make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])); return
                    await update.message.reply_text("Ø±Ù…Ø² Ø§Ù„Ø·Ù„Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ Ø§ÙƒØªØ¨ Ø§Ø³Ù…Ùƒ."); state["step"] = "name"; return
                if state.get("step") == "name":
                    if text.isdigit():
                        sub = fetch_subscriber_by_id(int(text))
                        if sub:
                            state["name"] = sub["name"]; state["phone"] = sub.get("phone"); state["step"] = "location" if state.get("phone") else "phone"
                            await update.message.reply_text("ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ØªØ±Ùƒ. Ø£Ø±Ø³Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ Ø£Ùˆ Ø£Ø¯Ø®Ù„ Ù‡Ø§ØªÙÙƒ:", reply_markup=make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])); return
                        req = fetch_client_request_by_id(int(text))
                        if req:
                            state["request_id"] = req["id"]; state["name"] = req.get("name"); state["phone"] = req.get("phone"); state["step"] = "location" if state.get("phone") else "phone"
                            await update.message.reply_text("ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨. Ø£Ø±Ø³Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ Ø£Ùˆ Ø§Ø¯Ø®Ù„ Ù‡Ø§ØªÙÙƒ:", reply_markup=make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])); return
                    state["name"] = text; state["step"] = "phone"; await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:"); return
                if state.get("step") == "phone":
                    if not is_valid_phone(text):
                        await update.message.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø±Ø³Ù„Ù‡ Ø¨ØµÙŠØºØ© 091xxxxxxx Ø£Ùˆ +2189xxxxxxx."); return
                    state["phone"] = normalize_phone(text); state["step"] = "location"
                    await update.message.reply_text("Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹' Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])); return
                if state.get("step") == "edu_choice":
                    # client chose which teaching division they want
                    state["edu_type"] = text
                    # after selecting edu_type proceed to phone/location as usual
                    if state.get("phone"):
                        state["step"] = "location"
                        kb = make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])
                        await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {state.get('edu_type')}\nØ§Ù„Ø¢Ù† Ø´Ø§Ø±Ùƒ Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
                    else:
                        state["step"] = "phone"
                        kb = make_reply_kb([[KeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„", request_contact=True)]])
                        await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {state.get('edu_type')}\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø¨Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:", reply_markup=kb)
                    return
            # worker flow
            if state.get("role") == "worker":
                if state.get("step") == "name":
                    state["name"] = text; state["step"] = "work_type"
                    # show top-level service categories first (same as clients) so the
                    # worker can pick a category or a direct service quickly.
                    cats = list(SERVICE_CATEGORIES.keys())
                    kb = make_reply_kb([[c] for c in cats])
                    await update.message.reply_text("Ø§Ø®ØªØ± Ø§Ù„ÙØ¦Ø©/Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ùƒ:", reply_markup=kb); return
                if state.get("step") == "work_type":
                    if text in WORK_TYPES:
                        state["work_type"] = text
                        # Special flow for educational services: ask for specific edu type to organize later
                        if text in EDUCATION_SERVICE_ALIASES:
                            # ask which teaching division (existing) and then ask for specialization
                            state["step"] = "edu_type"
                            edu_kb = make_reply_kb([
                                ["ØªÙ…Ù‡ÙŠØ¯ÙŠ", "Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ"],
                                ["Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯", "Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ"]
                            ])
                            await update.message.reply_text("Ø§Ø®ØªØ± Ù‚Ø³Ù… Ø§Ù„ØªØ¯Ø±ÙŠØ³ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ùƒ (ØªÙ…Ù‡ÙŠØ¯ÙŠ / Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ / Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯ / Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ):", reply_markup=edu_kb)
                        # Special flow for internet technicians: ask for company name
                        elif text == "ÙÙ†ÙŠ Ø§Ù†ØªØ±Ù†Øª":
                            state["step"] = "company_name"
                            await update.message.reply_text("Ù…Ø§ Ø§Ø³Ù… Ø§Ù„Ø´Ø±ÙƒØ© Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¨Ù‡Ø§ØŸ (Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ø´Ø±ÙƒØ© Ø£Ùˆ Ø§ÙƒØªØ¨ 'ÙØ±Ø¯ÙŠ' Ø¥Ø°Ø§ ØªØ¹Ù…Ù„ Ù„Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ø®Ø§Øµ)")
                        # Special flow for flooring workers: ask for their specific specialization
                        elif text == "Ø£Ø±Ø¶ÙŠØ§Øª":
                            state["step"] = "work_specialization"
                            await update.message.reply_text("Ù…Ø§ ØªØ®ØµØµÙƒ Ø¯Ø§Ø®Ù„ Ù…Ø¬Ø§Ù„ Ø§Ù„Ø£Ø±Ø¶ÙŠØ§ØªØŸ (Ù…Ø«Ø§Ù„: ØªØ±ÙƒÙŠØ¨ Ø¨Ù„Ø§Ø·ØŒ ØµÙ‚Ù„ Ø£Ø±Ø¶ÙŠØ§ØªØŒ ØªØ±ÙƒÙŠØ¨ Ø³ÙŠØ±Ø§Ù…ÙŠÙƒØŒ ...)")
                        # Special flow for vehicle transport services: ask for vehicle type
                        elif text == "Ø³ÙŠØ§Ø±Ø§Øª Ù†Ù‚Ù„":
                            state["step"] = "vehicle_type"
                            await update.message.reply_text("Ù…Ø§ Ù†ÙˆØ¹ Ø³ÙŠØ§Ø±ØªÙƒØŸ (Ù…Ø«Ø§Ù„: Ù†Ù‚Ù„ Ø£Ø«Ø§Ø«ØŒ Ù†Ù‚Ù„ Ø¨Ø¶Ø§Ø¦Ø¹ØŒ Ø´Ø§Ø­Ù†Ø© ØµØºÙŠØ±Ø©ØŒ ...)")
                        else:
                            state["step"] = "phone"
                            await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:")
                    else:
                        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù…Ù„ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±.")
                    return
                if state.get("step") == "edu_type":
                    # store the educational service subtype and then ask for specialization
                    state["edu_type"] = text
                    state["step"] = "edu_specialization"
                    await update.message.reply_text("Ù…Ø§ ØªØ®ØµØµÙƒ Ø¯Ø§Ø®Ù„ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø³Ù…ØŸ (Ù…Ø«Ø§Ù„: Ø±ÙŠØ§Ø¶ Ø£Ø·ÙØ§Ù„ØŒ Ù„ØºØ© Ø¹Ø±Ø¨ÙŠØ©ØŒ ÙÙŠØ²ÙŠØ§Ø¡ØŒ ...)")
                    return
                if state.get("step") == "edu_specialization":
                    state["edu_specialization"] = text
                    state["step"] = "phone"
                    await update.message.reply_text("Ø´ÙƒØ±Ù‹Ø§. Ø§Ù„Ø¢Ù† Ø§Ø¯Ø®Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ø´Ø§Ø±Ùƒ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:")
                    return
                if state.get("step") == "work_specialization":
                    # store the flooring/work specialization and continue to phone step
                    state["work_specialization"] = text
                    state["step"] = "phone"
                    await update.message.reply_text("Ø´ÙƒØ±Ù‹Ø§. Ø§Ù„Ø¢Ù† Ø§Ø¯Ø®Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ø´Ø§Ø±Ùƒ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:")
                    return
                if state.get("step") == "company_name":
                    state["company_name"] = text
                    state["step"] = "phone"
                    await update.message.reply_text("Ø´ÙƒØ±Ù‹Ø§. Ø§Ù„Ø¢Ù† Ø§Ø¯Ø®Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ø´Ø§Ø±Ùƒ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:")
                    return
                if state.get("step") == "vehicle_type":
                    # store the vehicle type and continue to phone step
                    state["vehicle_type"] = text
                    state["step"] = "phone"
                    await update.message.reply_text("Ø´ÙƒØ±Ù‹Ø§. Ø§Ù„Ø¢Ù† Ø§Ø¯Ø®Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ø´Ø§Ø±Ùƒ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:")
                    return
                if state.get("step") == "phone":
                    raw = text; logging.info("Worker phone raw input: %r from user %s", raw, user_id)
                    norm = normalize_phone(raw)
                    if not norm:
                        await update.message.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø±Ø³Ù„Ù‡ Ø¨ØµÙŠØºØ© 0912xxxxxx Ø£Ùˆ +2189xxxxxxx. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:"); return
                    state["phone"] = norm
                    # Persist an initial worker row now so coupon redemption (which
                    # updates the workers table) will succeed even before we have
                    # the location. save_worker_to_db will INSERT or UPDATE as needed.
                    try:
                        save_worker_to_db(user_id, state)
                    except Exception:
                        logging.exception("Failed to pre-save worker before subscription selection")
                    state["step"] = "choose_sub"
                    # Ø¹Ø±Ø¶ Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø© Ø¨Ø¯Ù„ Ø·Ù„Ø¨ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¨Ø§Ø´Ø±Ø©
                    sub_kb = InlineKeyboardMarkup([
                        [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ© â€” 100 Ø¯.Ù„", callback_data=f"pick_sub:gold")],
                        [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ¶ÙŠØ© â€” 60 Ø¯.Ù„", callback_data=f"pick_sub:silver")],
                        [InlineKeyboardButton("Ù„ÙŠØ³ Ø§Ù„Ø¢Ù†", callback_data="skip_sub")]
                    ])
                    await update.message.reply_text("Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªÙØ¹ÙŠÙ„Ù‡ Ø«Ù… Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ø£Ùˆ Ø§Ø®ØªØ± 'Ù„ÙŠØ³ Ø§Ù„Ø¢Ù†' Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¯ÙˆÙ† Ø§Ø´ØªØ±Ø§Ùƒ:", reply_markup=sub_kb)
                    return
                if state.get("step") == "await_coupon_code":
                    code_input = text.strip()
                    if not code_input:
                        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ ØµØ§Ù„Ø­."); return

                    ok, msg = redeem_coupon_for_worker(code_input, user_id, target_worker_user_id=user_id, desired_tier=state.get("desired_tier"))
                    await update.message.reply_text(msg)
                    if ok:
                        # coupon applied (DB updated). Continue to request location
                        # so we can save the worker's coordinates and complete
                        # registration.
                        state["step"] = "location"
                        user_states[user_id] = state
                        kb = make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])
                        await update.message.reply_text("ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ. Ø§Ù„Ø¢Ù† Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„:", reply_markup=kb)
                    return
            # view_my_account flow: user enters a worker code to view their stats
            if state.get("role") == "view_my_account":
                if state.get("step") == "enter_code":
                    code_text = text.strip()
                    try:
                        code_val = int(re.sub(r"\D", "", code_text))
                    except Exception:
                        await update.message.reply_text("Ø§Ù„ÙƒÙˆØ¯ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø±Ù‚Ù…ÙŠØ§Ù‹. Ø£Ø¹Ø¯ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:")
                        return
                    w = fetch_worker_by_code(code_val)
                    if not w:
                        await update.message.reply_text("Ù„Ù… Ø£Ø¬Ø¯ Ø¹Ø§Ù…Ù„Ø§Ù‹ Ø¨Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø±Ù‚Ù… ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                        return
                    # Allow viewing by code: do NOT require user_id ownership match.
                    # (This enables a worker to view their record by entering their code.)
                    # fetch rating stats for this worker
                    cnt, avg = fetch_rating_stats(w.get("user_id"))
                    # format subscription expiry as date only (YYYY-MM-DD)
                    sub_exp = w.get("subscription_expiry") or ""
                    try:
                        if sub_exp and sub_exp != "":
                            exp_dt = datetime.fromisoformat(sub_exp)
                            sub_exp_fmt = exp_dt.strftime("%Y-%m-%d")
                        else:
                            sub_exp_fmt = "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§Ø´ØªØ±Ø§Ùƒ"
                    except Exception:
                        sub_exp_fmt = str(sub_exp)
                    appearance = w.get("appearance_count", 0) or 0
                    selected = w.get("selected_count", 0) or 0
                    ratings_received = cnt or 0
                    work_type = w.get("work_type") or "-"
                    # subscription level name
                    try:
                        lvl = int(w.get("subscription_level") or 0)
                    except Exception:
                        lvl = 0
                    if lvl == 1:
                        sub_name = "Ø°Ù‡Ø¨ÙŠ"
                    elif lvl == 2:
                        sub_name = "ÙØ¶ÙŠ"
                    else:
                        sub_name = "Ø¨Ù„Ø§ Ø§Ø´ØªØ±Ø§Ùƒ"

                    msg = (
                        f"Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ (Ø§Ù„ÙƒÙˆØ¯: {code_val}):\n"
                        f"Ù†ÙˆØ¹ Ø§Ù„ÙØ¦Ø©: {work_type}\n"
                        f"ÙØ¦Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ: {sub_name}\n"
                        f"ØªØ§Ø±ÙŠØ® Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ: {sub_exp_fmt}\n"
                        f"Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø¸Ù‡ÙˆØ±: {appearance}\n"
                        f"Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±: {selected}\n"
                        f"Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª (Ø¹Ø¯Ø¯/Ù…ØªÙˆØ³Ø·): {ratings_received} / {avg:.2f}\n"
                    )
                    await update.message.reply_text(msg, reply_markup=MAIN_KB)
                    user_states.pop(user_id, None)
                    return

            # redeem flow
            if state.get("role") == "redeem" and state.get("step") == "code":
                code = text.strip(); ok, msg = redeem_coupon_for_worker(code, user_id)
                await update.message.reply_text(msg); user_states.pop(user_id, None); return
    except Exception:
        logging.exception("Error in handle_buttons")
        try:
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø¯Ø§Ø®Ù„ÙŠ. Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ Ø§ÙƒØªØ¨ /start.")
        except Exception:
            pass
    await update.message.reply_text("Ù„Ù… Ø£ÙÙ‡Ù…. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ùˆ Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©.", reply_markup=MAIN_KB)

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        msg = update.message
        if not msg or not msg.contact:
            return
        user_id = msg.from_user.id
        phone_raw = msg.contact.phone_number
        logging.info("handle_contact: user=%s phone=%r", user_id, phone_raw)
        if not phone_raw:
            await msg.reply_text("Ù„Ù… Ù†ØªÙ„Ù‚Ù Ø±Ù‚Ù… Ù‡Ø§ØªÙ. Ø£Ø¹Ø¯ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„."); return
        phone = normalize_phone(phone_raw)
        if not phone:
            await msg.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø³ØªØ®Ø¯Ù… 091xxxxxxx Ø£Ùˆ +2189xxxxxxx."); return
        state = user_states.get(user_id)
        if not state:
            await msg.reply_text("Ø§Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /start."); return
        role = state.get("role"); step = state.get("step")
        if role in ("subscriber", "client") and step == "phone":
            state["phone"] = phone; state["step"] = "location"
            kb = make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])
            await msg.reply_text("ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø±Ù‚Ù…Ùƒ. Ø§Ù„Ø¢Ù† Ø´Ø§Ø±Ùƒ Ù…ÙˆÙ‚Ø¹Ùƒ.", reply_markup=kb); return
        if role == "worker" and step == "phone":
            state["phone"] = phone
            # Persist an initial worker row so subsequent coupon redemption can
            # update the worker record. Then show subscription choices (with
            # an option to skip and continue to location sharing).
            try:
                save_worker_to_db(user_id, state)
            except Exception:
                logging.exception("Failed to pre-save worker from contact share")
            state["step"] = "choose_sub"
            sub_kb = InlineKeyboardMarkup([
                [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ© â€” 100 Ø¯.Ù„", callback_data=f"pick_sub:gold")],
                [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ¶ÙŠØ© â€” 60 Ø¯.Ù„", callback_data=f"pick_sub:silver")],
                [InlineKeyboardButton("Ù„ÙŠØ³ Ø§Ù„Ø¢Ù†", callback_data="skip_sub")]
            ])
            await msg.reply_text("ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø±Ù‚Ù…Ùƒ. Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø£Ùˆ Ø§Ø®ØªØ± 'Ù„ÙŠØ³ Ø§Ù„Ø¢Ù†' Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ø¯ÙˆÙ† Ø§Ø´ØªØ±Ø§Ùƒ:", reply_markup=sub_kb)
            return
        await msg.reply_text("ØªÙ… Ø­ÙØ¸ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„. ØªØ§Ø¨Ø¹ Ø£Ùˆ Ø§ÙƒØªØ¨ /start.")
    except Exception:
        logging.exception("Error in handle_contact")
        try:
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„. Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ /start.")
        except Exception:
            pass

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        if not query:
            return
        await query.answer()
        data = query.data or ""
        user_id = query.from_user.id

        # pick activation from activation flow
        if data.startswith("pick_activate:"):
            parts = data.split(":" )
            if len(parts) != 3:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                return
            tier = parts[1]
            target_user = int(parts[2])
            state = user_states.get(user_id, {})
            # ensure the state matches
            state["desired_tier"] = tier
            state["target_user_id"] = target_user
            state["step"] = "awaiting_coupon"
            user_states[user_id] = state
            try:
                await query.edit_message_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª Ø§Ù„ÙØ¦Ø©: {'Ø°Ù‡Ø¨ÙŠØ©' if tier=='gold' else 'ÙØ¶ÙŠØ©'}\\.\nØ£Ø¯Ø®Ù„ Ø§Ù„Ø¢Ù† ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©:")
            except Exception:
                await query.message.reply_text("Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¢Ù† ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©:")
            return

        # user chose subscription type during Ø§Ù„ØªØ³Ø¬ÙŠÙ„
        if data.startswith("pick_sub:"):
            parts = data.split(":")
            if len(parts) != 2:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                return
            tier = parts[1]
            state = user_states.get(user_id, {})
            if state.get("role") != "worker":
                await query.edit_message_text("Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§ØµÙŠØ© Ù…ØªØ§Ø­Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø§Ù…Ù„ÙŠÙ† Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„.")
                return
            state["desired_tier"] = tier
            state["step"] = "await_coupon_code"
            user_states[user_id] = state
            try:
                await query.edit_message_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª Ø§Ù„ÙØ¦Ø©: {'Ø°Ù‡Ø¨ÙŠØ©' if tier=='gold' else 'ÙØ¶ÙŠØ©'}\\.\nØ£Ø¯Ø®Ù„ Ø§Ù„Ø¢Ù† ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©:")
            except Exception:
                await query.message.reply_text("Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¢Ù† ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©:")
            return

        # skip subscription for worker during registration: proceed to location
        if data == "skip_sub":
            state = user_states.get(user_id, {})
            if state.get("role") != "worker":
                try:
                    await query.edit_message_text("Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§ØµÙŠØ© Ù…ØªØ§Ø­Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø§Ù…Ù„ÙŠÙ† Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„.")
                except Exception:
                    pass
                return
            state["step"] = "location"
            user_states[user_id] = state
            kb = make_reply_kb([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]])
            try:
                await query.edit_message_text("ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¹Ø¯Ù… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¢Ù†. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„.")
            except Exception:
                pass
            try:
                await query.message.reply_text("Ø§Ø¶ØºØ· Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
            except Exception:
                logging.debug("Failed to send location prompt after skip_sub callback")
            return

        # ... other callback handling continues ...
    except Exception:
        logging.exception("Error in handle_callback")
        try:
            if update.callback_query:
                await update.callback_query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©.")
        except Exception:
            pass

# Remaining unchanged code follows (identical to vscode-local copy)...
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters, CallbackQueryHandler
import math
import sqlite3
import os
import logging
import asyncio
import sys
import re
from datetime import datetime, timedelta
import random
import string
import time
import traceback
from dotenv import load_dotenv
import requests
import psutil  # optional: for robust PID check (install psutil) or use os

load_dotenv()  # Ø³ÙŠØ­Ù…Ù‘Ù„ Ø§Ù„Ù‚ÙŠÙ… Ù…Ù† .env ÙÙŠ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹

# Ø¥Ø³ÙƒØ§Øª ØªØ­Ø°ÙŠØ±Ø§Øª Deprecation Ø§Ù„Ø¹Ø§Ù…Ø© Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ asyncio.WindowsSelectorEventLoopPolicy
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO)

TOKEN = os.getenv("BOT_TOKEN")
if not TOKEN:
    raise SystemExit("BOT_TOKEN missing")
DATA_ENC_KEY = os.getenv("DATA_ENC_KEY")
if not DATA_ENC_KEY:
    raise SystemExit("DATA_ENC_KEY missing")
try:
    ADMIN_ID = int(os.getenv("ADMIN_USER_ID", "0")) or 0
except Exception:
    ADMIN_ID = 0

WORK_TYPES = [
    "Ø³Ø¨Ø§ÙƒØ©", "ØªØ±ÙƒÙŠØ¨ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª", "Ø·Ù„Ø§Ø¡ Ù…Ù†Ø§Ø²Ù„", "ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ Ù…Ù†Ø§Ø²Ù„", "Ø´Ø§Ø­Ù†Ø§Øª Ù…ÙŠØ§Ù‡ ØµØ§Ù„Ø­Ø© Ù„Ù„Ø´Ø±Ø¨",
    "Ø¹Ø§Ù…Ù„Ø§Øª Ù†Ø¸Ø§ÙØ© ÙˆØ£Ø´ØºØ§Ù„ Ø¹Ø§Ù…Ø©", "ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¬Ø§Ø¯ Ùˆ Ø§Ù„Ù…ÙØ±ÙˆØ´Ø§Øª ÙÙŠ Ø§Ù„Ù…Ù†Ø²Ù„", "ÙÙ†ÙŠ Ø§Ù†ØªØ±Ù†Øª", "ØªÙˆØµÙŠÙ„ Ø±Ø¬Ø§Ù„ÙŠ", "ØªÙˆØµÙŠÙ„ Ù†Ø³Ø§Ø¦ÙŠ", "Ø³ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø§Ø³Ø¹Ø§Ù",
    "ØªØµÙˆÙŠØ± Ù…Ù†Ø§Ø³Ø¨Ø§Øª",
    "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©", "Ø£Ø®Ø±Ù‰"
]

SERVICE_KEYS = {"Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "ğŸ› ï¸ Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "Ø§Ù„Ø®Ø¯Ù…Ø©", "Ø®Ø¯Ù…Ø§Øª", "Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "Ø³ÙŠØ±ÙØ²", "Ø³Ø±ÙØ²"}
CONTACT_KEYS = {"ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§", "Ø§ØªØµÙ„ Ø¨Ù†Ø§", "ØªÙˆØ§ØµÙ„", "Ø§ØªØµÙ„", "ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"}
ABOUT_KEYS = {"Ù†Ø¨Ø°Ø© Ø¹Ù†Ø§", "ğŸ“œ Ù†Ø¨Ø°Ø© Ø¹Ù†Ø§", "ğŸ“œÙ†Ø¨Ø°Ø© Ø¹Ù†Ø§", "Ù†Ø¨Ø°Ø©", "Ø¹Ù† Ø§Ù„ØªØ·Ø¨ÙŠÙ‚", "Ù…Ù† Ù†Ø­Ù†"}

# Main persistent keyboard used across client interactions. Use this single instance
# so all entry points present the same buttons and avoid disappearing rows.
# Keep MAIN_MENU_LAYOUT consistent with the earlier, canonical definition above.
# If the earlier block exists it will be reused; otherwise fall back to a sensible default.
try:
    # reuse the first definition of MAIN_MENU_LAYOUT (preferred)
    MAIN_MENU_LAYOUT = MAIN_MENU_LAYOUT
except NameError:
    MAIN_MENU_LAYOUT = [["ğŸ› ï¸ Ø§Ù„Ø®Ø¯Ù…Ø§Øª", "ğŸ“ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†"], ["ğŸ”“ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", "ğŸ“ŠØ­Ø³Ø§Ø¨ÙŠ"], ["ğŸ“œ Ù†Ø¨Ø°Ø© Ø¹Ù†Ø§", "ğŸ“ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"]]
MAIN_KB = ReplyKeyboardMarkup(MAIN_MENU_LAYOUT, resize_keyboard=True)

user_states = {}
workers = {}

DB_PATH = os.path.join(os.path.dirname(__file__), "data.db")
LOCKFILE = os.path.join(os.path.dirname(__file__), "bot.lock")

# Windows event loop policy (suppress DeprecationWarning when calling)
import sys, asyncio
import warnings
# ÙÙ‚Ø· Ø§Ø¶Ø¨Ø· Ø³ÙŠØ§Ø³Ø© Ø§Ù„Ø­Ù„Ù‚Ø© Ø¹Ù„Ù‰ ÙˆÙŠÙ†Ø¯ÙˆØ² Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù†Ø³Ø®Ø© Ø¨Ø§ÙŠØ«ÙˆÙ† Ø£Ù‚Ù„ Ù…Ù† 3.16
if sys.platform.startswith("win"):
    try:
        if sys.version_info < (3, 16) and hasattr(asyncio, "WindowsSelectorEventLoopPolicy"):
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", category=DeprecationWarning, message=".*WindowsSelectorEventLoopPolicy.*")
                warnings.filterwarnings("ignore", category=DeprecationWarning, message=".*set_event_loop_policy.*")
                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    except Exception:
        pass

# ---------- DB init ----------
def add_column_if_not_exists(conn, table, column_def):
    """column_def example: 'appearance_count INTEGER DEFAULT 0'"""
    colname = column_def.split()[0]
    cur = conn.cursor()
    cur.execute(f"PRAGMA table_info({table})")
    cols = [r[1] for r in cur.fetchall()]
    if colname not in cols:
        cur.execute(f"ALTER TABLE {table} ADD COLUMN {column_def}")
        conn.commit()

def init_db():
    try:
        logging.info("Init DB -> %s", DB_PATH)
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()

        cur.execute("""
        CREATE TABLE IF NOT EXISTS workers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER UNIQUE,
            name TEXT,
            phone TEXT,
            work_type TEXT,
            lat REAL,
            lon REAL,
            worker_code INTEGER,
            coupon_code TEXT,
            subscription_level INTEGER DEFAULT 0,
            subscription_expiry TIMESTAMP
        )
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            name TEXT,
            phone TEXT,
            service TEXT,
            lat REAL,
            lon REAL,
            assigned_worker_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS coupons (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT UNIQUE,
            amount INTEGER,
            used INTEGER DEFAULT 0,
            used_by_worker_user_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            used_at TIMESTAMP
        )
        """)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS ratings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            worker_user_id INTEGER,
            client_user_id INTEGER,
            rating INTEGER,
            comment TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)

        # usage_stats table to track total users/requests
        cur.execute("""
        CREATE TABLE IF NOT EXISTS usage_stats (
            id INTEGER PRIMARY KEY CHECK (id = 1),
            total_users INTEGER DEFAULT 0,
            total_requests INTEGER DEFAULT 0
        )
        """)
        cur.execute("INSERT OR IGNORE INTO usage_stats (id, total_users, total_requests) VALUES (1,0,0)")

        # table to track if we've greeted a user before (so first-time users get the full menu)
        cur.execute("""
        CREATE TABLE IF NOT EXISTS seen_users (
            user_id INTEGER PRIMARY KEY,
            first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)

        conn.commit()

        # Ensure counter columns exist on workers (safe migration)
        try:
            add_column_if_not_exists(conn, "workers", "appearance_count INTEGER DEFAULT 0")
            add_column_if_not_exists(conn, "workers", "ratings_received INTEGER DEFAULT 0")
            add_column_if_not_exists(conn, "workers", "selected_count INTEGER DEFAULT 0")
            # new column to record education service subtype for workers who register under educational services
            add_column_if_not_exists(conn, "workers", "education_type TEXT")
        except Exception:
            logging.exception("Failed adding counter columns")

        conn.commit()
        conn.close()
        logging.info("Database initialized / migrated successfully.")
    except Exception:
        logging.exception("init_db error")

# ---------- Counters / stats helpers ----------
def increment_worker_appearance(worker_user_id, by=1):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("UPDATE workers SET appearance_count = COALESCE(appearance_count,0) + ? WHERE user_id = ?", (by, worker_user_id))
        conn.commit()
    finally:
        conn.close()

def increment_worker_selected(worker_user_id, by=1):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("UPDATE workers SET selected_count = COALESCE(selected_count,0) + ? WHERE user_id = ?", (by, worker_user_id))
        conn.commit()
    finally:
        conn.close()

def increment_worker_ratings(worker_user_id, by=1):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("UPDATE workers SET ratings_received = COALESCE(ratings_received,0) + ? WHERE user_id = ?", (by, worker_user_id))
        conn.commit()
    finally:
        conn.close()

def increment_usage_on_request(user_id):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        # Ø§Ø°Ø§ Ù‡Ø°Ù‡ Ø£ÙˆÙ„ Ù…Ø±Ø© ÙŠØ·Ù„Ø¨ ÙÙŠÙ‡Ø§ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø²ÙØ¯Ù‘ total_users
        cur.execute("SELECT COUNT(*) FROM clients WHERE user_id = ?", (user_id,))
        prior = cur.fetchone()[0] or 0
        if prior == 0:
            cur.execute("UPDATE usage_stats SET total_users = COALESCE(total_users,0) + 1 WHERE id = 1")
        # Ø¯ÙˆÙ‘Ù† Ø§Ù„Ø·Ù„Ø¨ ÙƒÙ€ total_requests
        cur.execute("UPDATE usage_stats SET total_requests = COALESCE(total_requests,0) + 1 WHERE id = 1")
        conn.commit()
    finally:
        conn.close()

# ---------- DB helpers (single copy) ----------
def save_worker_to_db(user_id, state):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    lat, lon = state.get("location", (None, None))
    cur.execute("SELECT id, worker_code FROM workers WHERE user_id = ?", (user_id,))
    existing = cur.fetchone()
    if existing:
        row_id, worker_code = existing
        cur.execute("UPDATE workers SET name = ?, phone = ?, work_type = ?, lat = ?, lon = ?, education_type = ? WHERE user_id = ?",
                    (state.get("name"), state.get("phone"), state.get("work_type"), lat, lon, state.get("edu_type"), user_id))
        # apply subscription fields if present in state
        if state.get("subscription_level") or state.get("subscription_expiry") or state.get("coupon_code"):
            try:
                cur.execute("UPDATE workers SET subscription_level = ?, subscription_expiry = ?, coupon_code = ? WHERE user_id = ?",
                            (state.get("subscription_level"), state.get("subscription_expiry"), state.get("coupon_code"), user_id))
            except Exception:
                logging.debug("Could not update subscription fields for existing worker")
        if not worker_code:
            worker_code = 2000 + row_id
            try:
                cur.execute("UPDATE workers SET worker_code = ? WHERE id = ?", (worker_code, row_id))
            except Exception:
                pass
        conn.commit()
        conn.close()
        return worker_code

    cur.execute("INSERT INTO workers (user_id, name, phone, work_type, lat, lon, education_type) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (user_id, state.get("name"), state.get("phone"), state.get("work_type"), lat, lon, state.get("edu_type")))
    conn.commit()
    rowid = cur.lastrowid
    worker_code = 2000 + rowid
    try:
        cur.execute("UPDATE workers SET worker_code = ? WHERE id = ?", (worker_code, rowid))
        conn.commit()
    except Exception:
        pass
    # Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø±Ø§Ø¬ØŒ Ø·Ø¨Ù‚ Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¥Ù† ÙˆÙØ¬Ø¯Øª
    try:
        if state.get("subscription_level") or state.get("subscription_expiry") or state.get("coupon_code"):
            cur.execute("UPDATE workers SET subscription_level = ?, subscription_expiry = ?, coupon_code = ? WHERE id = ?",
                        (state.get("subscription_level"), state.get("subscription_expiry"), state.get("coupon_code"), rowid))
            conn.commit()
    except Exception:
        logging.debug("Could not set subscription fields for new worker")
    conn.close()
    return worker_code

def save_client_request_to_db(user_id, state, req_id=None):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    lat, lon = state.get("location", (None, None))
    name = state.get("name")
    phone = state.get("phone")
    service = state.get("service")
    if req_id:
        cur.execute("UPDATE clients SET user_id=?, name=?, phone=?, service=?, lat=?, lon=?, created_at=CURRENT_TIMESTAMP WHERE id=?",
                    (user_id, name, phone, service, lat, lon, req_id))
        conn.commit()
        cid = req_id
    else:
        cur.execute("INSERT INTO clients (user_id, name, phone, service, lat, lon) VALUES (?,?,?,?,?,?)",
                    (user_id, name, phone, service, lat, lon))
        conn.commit()
        cid = cur.lastrowid
        # ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯
        try:
            increment_usage_on_request(user_id)
        except Exception:
            logging.exception("Failed to increment usage stats")
    conn.close()
    return cid


def mark_user_seen(user_id):
    """Return True if this is the first time we've seen this user (inserted), False otherwise."""
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT 1 FROM seen_users WHERE user_id = ?", (user_id,))
        if cur.fetchone():
            conn.close(); return False
        cur.execute("INSERT INTO seen_users (user_id) VALUES (?)", (user_id,))
        conn.commit(); conn.close(); return True
    except Exception:
        try:
            conn.close()
        except Exception:
            pass
        return False

def save_rating_to_db(worker_user_id, client_user_id, rating, comment=None):
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()
    try:
        cur.execute("INSERT INTO ratings (worker_user_id, client_user_id, rating, comment) VALUES (?,?,?,?)",
                    (worker_user_id, client_user_id, int(rating), comment))
        conn.commit()
        # Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…Ø§Øª Ù„Ù„Ø¹Ø§Ù…Ù„
        try:
            increment_worker_ratings(worker_user_id, by=1)
        except Exception:
            logging.exception("Failed to increment worker ratings counter")
    finally:
        conn.close()

# ---------- Bot handlers ----------
async def redeem_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_states[user_id] = {"role": "redeem", "step": "code"}
    await update.message.reply_text("Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø´Ø­Ù† (Ø§Ù„ÙƒÙˆØ¨ÙˆÙ†) Ù„ØªÙØ¹ÙŠÙ„Ù‡:")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_states.pop(user_id, None)
    await update.message.reply_text("Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨ÙƒÙ… ÙÙŠ Ø¨ÙˆØª Ø®Ø¯Ù…ØªÙŠ", reply_markup=MAIN_KB)

async def send_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else None
    if not ADMIN_ID or uid != ADMIN_ID:
        await update.message.reply_text("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.")
        return
    try:
        subs = fetch_subscribers()
        sub_count = len(subs)
        conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM workers"); workers_count = cur.fetchone()[0] or 0
        cur.execute("SELECT id, name, phone, work_type, worker_code, subscription_level, subscription_expiry FROM workers ORDER BY id DESC LIMIT 1000"); wrows = cur.fetchall()
        conn.close()
    except Exception:
        logging.exception("send_admin_panel failed")
        await update.message.reply_text("ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.")
        return

    header = f"Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\nØ§Ù„Ù…Ø´ØªØ±ÙƒÙˆÙ†: {sub_count}\nØ§Ù„Ø¹Ù…Ø§Ù„: {workers_count}\n\n"
    sub_lines = [f"{s['id']} | {s['name'] or '-'} | {s['phone'] or '-'}" for s in subs]
    subs_text = "Ø§Ù„Ù…Ø´ØªØ±ÙƒÙˆÙ† (Ø¢Ø®Ø±):\n" + ("\n".join(sub_lines) if sub_lines else "(Ù„Ø§ Ø³Ø¬Ù„Ø§Øª)")
    w_lines = [f"{wid} | {name or '-'} | {phone or '-'} | {wtype or '-'} | code:{wcode or '-'} | lvl:{level or 0} | exp:{expiry or '-'}" for wid, name, phone, wtype, wcode, level, expiry in wrows]
    workers_text = "Ø§Ù„Ø¹Ù…Ø§Ù„ (Ø¢Ø®Ø±):\n" + ("\n".join(w_lines) if w_lines else "(Ù„Ø§ Ø³Ø¬Ù„Ø§Øª)")
    OUT_LIMIT = 3500
    await update.message.reply_text(header)
    if len(subs_text) > OUT_LIMIT:
        from io import BytesIO
        bio = BytesIO(subs_text.encode("utf-8")); bio.name = "subscribers.txt"
        await update.message.reply_document(bio)
    else:
        await update.message.reply_text(subs_text)
    if len(workers_text) > OUT_LIMIT:
        from io import BytesIO
        bio = BytesIO(workers_text.encode("utf-8")); bio.name = "workers.txt"
        await update.message.reply_document(bio)
    else:
        await update.message.reply_text(workers_text)

async def handle_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.message.from_user.id if update.message and update.message.from_user else None
        # greet first-time users with the full main keyboard so anyone who opens the bot
        # immediately sees the available options.
        try:
            if user_id:
                if mark_user_seen(user_id):
                    try:
                        await update.message.reply_text("Ù…Ø±Ø­Ø¨Ù‹Ø§! Ø¥Ù„ÙŠÙƒ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=MAIN_KB)
                    except Exception:
                        logging.debug("Could not send first-time welcome keyboard to user %s", user_id)
        except Exception:
            logging.debug("mark_user_seen failed for user %s", user_id)
        text_orig = ""
        contact_obj = None
        if update.message:
            contact_obj = getattr(update.message, "contact", None)
            if contact_obj and getattr(contact_obj, "phone_number", None):
                text_orig = contact_obj.phone_number
            elif update.message.text:
                text_orig = update.message.text
        logging.info("RAW_MSG repr: %r ; contact=%r ; from=%s", text_orig, contact_obj, user_id)
        text = text_orig.strip()
        text_l = text.lower()
        if "conf" in text_l:
            await send_admin_panel(update, context); return
        if text_l in CONTACT_KEYS:
            phone_local = "0916564000"; phone_international = "+218916564000"; wa_number = "218916564000"
            try:
                await update.message.reply_contact(phone_number=phone_international, first_name="ÙØ±ÙŠÙ‚ Ø§Ù„Ø¯Ø¹Ù…")
            except Exception:
                logging.debug("reply_contact failed")
            wa_btn = InlineKeyboardMarkup([[InlineKeyboardButton("Ù…Ø±Ø§Ø³Ù„ØªÙ†Ø§ Ø¹Ø¨Ø± ÙˆØ§ØªØ³Ø§Ø¨", url=f"https://wa.me/{wa_number}")]])
            # include phone number with phone emoji in the reply
            await update.message.reply_text(f"ğŸ“ Ù„Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ù‡Ø§ØªÙÙŠ: {phone_local}\n\nÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ù‹Ø§ Ù…Ø±Ø§Ø³Ù„ØªÙ†Ø§ Ø¹Ø¨Ø± ÙˆØ§ØªØ³Ø§Ø¨:", reply_markup=wa_btn)
            return
        if text_l in ABOUT_KEYS:
            about_text = (
                "Ø¨ÙˆØª Ø®Ø¯Ù…ØªÙŠ | ØªØ£Ø³Ø³ Ø¹Ø§Ù… 2025\n\n"
                "Ù†Ø­Ù† Ø¨ÙˆØª ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ÙŠÙ‡Ø¯Ù Ø¥Ù„Ù‰ ØªØ³Ù‡ÙŠÙ„ Ø·Ù„Ø¨ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙˆØ§Ù„Ø­Ø±ÙÙŠÙŠÙ†.\n"
                "ÙƒÙ„ Ù…Ø§ Ø¹Ù„ÙŠÙƒ Ù‡Ùˆ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ø«Ù… Ø¥Ø±Ø³Ø§Ù„ Ù…ÙˆÙ‚Ø¹ÙƒØŒ ÙˆØ³ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ø§Ù„Ø¨ÙˆØª Ø£Ù‚Ø±Ø¨ Ø­Ø±ÙÙŠ Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙˆØ§ØµÙ„.\n\n"
                "âœ… Ø§Ù„Ø®Ø¯Ù…Ø© Ù…Ø¬Ø§Ù†ÙŠØ© ØªÙ…Ø§Ù…Ù‹Ø§ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡\n"
                "ğŸ’¼ ÙˆØ§Ø´ØªØ±Ø§Ùƒ Ø±Ù…Ø²ÙŠ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†\n\n"
                "Ù„Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø± Ø£Ùˆ Ø¯Ø¹Ù…ØŒ Ù„Ø§ ØªØªØ±Ø¯Ø¯ ÙÙŠ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ ğŸ’¬"
            )
            await update.message.reply_text(about_text, reply_markup=ReplyKeyboardRemove())
            await update.message.reply_text("Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=MAIN_KB)
            return

        # If user types "Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡" inform them registration removed
        if text_l == "Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡":
            await update.message.reply_text("ØªÙ…Øª Ø¥Ø²Ø§Ù„Ø© Ø®Ø§ØµÙŠØ© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡. Ø¹Ù†Ø¯ Ø±ØºØ¨ØªÙƒ Ø¨Ø·Ù„Ø¨ Ø®Ø¯Ù…Ø© Ø§Ø®ØªØ± 'Ø§Ù„Ø®Ø¯Ù…Ø§Øª' Ø«Ù… ØªØ§Ø¨Ø¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø¨ÙŠØ§Ù†Ø§ØªÙƒ ÙˆÙ…ÙˆÙ‚Ø¹Ùƒ ÙˆØ³ÙŠÙØ³Ø¬Ù„ Ø§Ù„Ø·Ù„Ø¨ Ù…Ø¨Ø§Ø´Ø±Ø©.")
            return

        # rest of existing logic unchanged...
        if text.isdigit() and user_id not in user_states:
            req = fetch_client_request_by_id(int(text))
            if req:
                await update.message.reply_text(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø±Ù‚Ù… {req['id']} â€” Ø§Ù„Ø§Ø³Ù…: {req['name'] or '-'} â€” Ø§Ù„Ù‡Ø§ØªÙ: {req['phone'] or '-'}")
                return
        if text_l in ("Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡", "ğŸ“ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡", "Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†", "ğŸ“ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†") or text_l in SERVICE_KEYS or text_l in ABOUT_KEYS or text_l in CONTACT_KEYS:
            user_states.pop(user_id, None)
        if text_l == "Ø§Ù„ØªØ¬ÙŠÙ„ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡":
            name = None
            if update.effective_user:
                fn = update.effective_user.first_name or ""; ln = update.effective_user.last_name or ""; name = (fn + " " + ln).strip() or None
            contact = getattr(update.message, "contact", None)
            phone = contact.phone_number if contact and getattr(contact, "phone_number", None) else None
            user_states[user_id] = {"role": "subscriber", "step": ("location" if phone else "phone"), "name": name, "phone": phone}
            if phone:
                kb = ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)
                await update.message.reply_text(f"ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³Ù… Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
            else:
                kb = ReplyKeyboardMarkup([[KeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„", request_contact=True)]], resize_keyboard=True, one_time_keyboard=True)
                await update.message.reply_text(f"Ø³ÙŠÙØ³ØªØ®Ø¯Ù… Ø§Ø³Ù… Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø¨Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:", reply_markup=kb)
            return
        if text_l in ("Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†", "ğŸ“ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø­Ø±ÙÙŠÙŠÙ†"):
            user_states[user_id] = {"role": "worker", "step": "name"}
            await update.message.reply_text("Ø³Ø¬Ù„ ÙƒØ¹Ø§Ù…Ù„ - ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù…Ùƒ:")
            return
        if text_l in SERVICE_KEYS:
            kb = ReplyKeyboardMarkup([[w] for w in WORK_TYPES], resize_keyboard=True, one_time_keyboard=True)
            await update.message.reply_text("Ø§Ø®ØªØ± Ø§Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:", reply_markup=kb)
            return
        if text in WORK_TYPES and user_id not in user_states:
            name = None
            if update.effective_user:
                fn = update.effective_user.first_name or ""; ln = update.effective_user.last_name or ""; name = (fn + " " + ln).strip() or None
            contact = getattr(update.message, "contact", None)
            phone = contact.phone_number if contact and getattr(contact, "phone_number", None) else None
            state = {"role": "client", "service": text, "name": name, "phone": phone}
            # If client requested educational services, ask which teaching division they want
            if text == "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©":
                state["step"] = "edu_choice"
                user_states[user_id] = state
                edu_kb = ReplyKeyboardMarkup([
                    ["ØªÙ…Ù‡ÙŠØ¯ÙŠ", "Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ"],
                    ["Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯", "Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ"]
                ], resize_keyboard=True, one_time_keyboard=True)
                await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {text}\nØ§Ø®ØªØ± Ù‚Ø³Ù… Ø§Ù„ØªØ¯Ø±ÙŠØ³ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù…Ø¹Ù„Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯Ù‡:", reply_markup=edu_kb)
                return
            if phone:
                state["step"] = "location"; user_states[user_id] = state
                kb = ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)
                await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {text}\nØ§Ù„Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø¢Ù† Ø´Ø§Ø±Ùƒ Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
            else:
                state["step"] = "phone"; user_states[user_id] = state
                kb = ReplyKeyboardMarkup([[KeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„", request_contact=True)]], resize_keyboard=True, one_time_keyboard=True)
                await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {text}\nØ³ÙŠÙØ³ØªØ®Ø¯Ù… Ø§Ø³Ù… Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ: {name or 'ØºÙŠØ± Ù…ØªÙˆÙØ±'}\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø¨Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:", reply_markup=kb)
            return
        if user_id in user_states:
            state = user_states[user_id]
            # subscriber flow
            if state.get("role") == "subscriber":
                if state.get("step") == "name":
                    state["name"] = text; state["step"] = "phone"
                    await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:"); return
                if state.get("step") == "phone":
                    if not is_valid_phone(text):
                        await update.message.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø±Ø³Ù„Ù‡ Ø¨ØµÙŠØºØ© 091xxxxxxx Ø£Ùˆ 9xxxxxxx Ø£Ùˆ +2189xxxxxxx."); return
                    state["phone"] = normalize_phone(text); state["step"] = "location"
                    kb = ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)
                    await update.message.reply_text("Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹' Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb); return
            # client flow
            if state.get("role") == "client":
                if state.get("step") == "awaiting_request_id":
                    if text.isdigit():
                        req = fetch_client_request_by_id(int(text))
                        if req:
                            state["name"] = req.get("name"); state["phone"] = req.get("phone")
                            state["step"] = "location" if state.get("phone") else "phone"
                            await update.message.reply_text("ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨. Ø£Ø±Ø³Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ Ø£Ùˆ Ø£Ø¯Ø®Ù„ Ù‡Ø§ØªÙÙƒ:", reply_markup=ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)); return
                    await update.message.reply_text("Ø±Ù…Ø² Ø§Ù„Ø·Ù„Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ Ø§ÙƒØªØ¨ Ø§Ø³Ù…Ùƒ."); state["step"] = "name"; return
                if state.get("step") == "name":
                    if text.isdigit():
                        sub = fetch_subscriber_by_id(int(text))
                        if sub:
                            state["name"] = sub["name"]; state["phone"] = sub.get("phone"); state["step"] = "location" if state.get("phone") else "phone"
                            await update.message.reply_text("ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø´ØªØ±Ùƒ. Ø£Ø±Ø³Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ Ø£Ùˆ Ø£Ø¯Ø®Ù„ Ù‡Ø§ØªÙÙƒ:", reply_markup=ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)); return
                        req = fetch_client_request_by_id(int(text))
                        if req:
                            state["request_id"] = req["id"]; state["name"] = req.get("name"); state["phone"] = req.get("phone"); state["step"] = "location" if state.get("phone") else "phone"
                            await update.message.reply_text("ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨. Ø£Ø±Ø³Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ Ø£Ùˆ Ø§Ø¯Ø®Ù„ Ù‡Ø§ØªÙÙƒ:", reply_markup=ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)); return
                    state["name"] = text; state["step"] = "phone"; await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:"); return
                if state.get("step") == "phone":
                    if not is_valid_phone(text):
                        await update.message.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø±Ø³Ù„Ù‡ Ø¨ØµÙŠØºØ© 091xxxxxxx Ø£Ùˆ +2189xxxxxxx."); return
                    state["phone"] = normalize_phone(text); state["step"] = "location"
                    await update.message.reply_text("Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹' Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)); return
                if state.get("step") == "edu_choice":
                    # client chose which teaching division they want
                    state["edu_type"] = text
                    # after selecting edu_type proceed to phone/location as usual
                    if state.get("phone"):
                        state["step"] = "location"
                        kb = ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)
                        await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {state.get('edu_type')}\nØ§Ù„Ø¢Ù† Ø´Ø§Ø±Ùƒ Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
                    else:
                        state["step"] = "phone"
                        kb = ReplyKeyboardMarkup([[KeyboardButton("Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„", request_contact=True)]], resize_keyboard=True, one_time_keyboard=True)
                        await update.message.reply_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª: {state.get('edu_type')}\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø¨Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡:", reply_markup=kb)
                    return
            # worker flow
            if state.get("role") == "worker":
                if state.get("step") == "name":
                    state["name"] = text; state["step"] = "work_type"
                    kb = ReplyKeyboardMarkup([[w] for w in WORK_TYPES], resize_keyboard=True, one_time_keyboard=True)
                    await update.message.reply_text("Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø¹Ù…Ù„Ùƒ:", reply_markup=kb); return
                if state.get("step") == "work_type":
                    if text in WORK_TYPES:
                        state["work_type"] = text
                        # Special flow for educational services: ask for specific edu type to organize later
                        if text == "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©":
                            state["step"] = "edu_type"
                            edu_kb = ReplyKeyboardMarkup([
                                ["ØªÙ…Ù‡ÙŠØ¯ÙŠ", "Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ"],
                                ["Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯", "Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ"]
                            ], resize_keyboard=True, one_time_keyboard=True)
                            await update.message.reply_text("Ø§Ø®ØªØ± Ù‚Ø³Ù… Ø§Ù„ØªØ¯Ø±ÙŠØ³ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ùƒ (ØªÙ…Ù‡ÙŠØ¯ÙŠ / Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ / Ø«Ø§Ù†ÙˆÙŠ Ø£Ùˆ Ù…Ø¹Ù‡Ø¯ / Ø§ÙƒØ§Ø¯ÙŠÙ…ÙŠ):", reply_markup=edu_kb)
                        else:
                            state["step"] = "phone"
                            await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:")
                    else:
                        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù…Ù„ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±.")
                    return
                if state.get("step") == "edu_type":
                    # store the educational service subtype and continue to phone step
                    state["edu_type"] = text
                    state["step"] = "phone"
                    await update.message.reply_text("Ø´ÙƒØ±Ù‹Ø§. Ø§Ù„Ø¢Ù† Ø§Ø¯Ø®Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ Ø£Ùˆ Ø´Ø§Ø±Ùƒ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„:")
                    return
                if state.get("step") == "phone":
                    raw = text; logging.info("Worker phone raw input: %r from user %s", raw, user_id)
                    norm = normalize_phone(raw)
                    if not norm:
                        await update.message.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø±Ø³Ù„Ù‡ Ø¨ØµÙŠØºØ© 0912xxxxxx Ø£Ùˆ +2189xxxxxxx. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰:"); return
                    state["phone"] = norm
                    state["step"] = "choose_sub"
                    # Ø¹Ø±Ø¶ Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø© Ø¨Ø¯Ù„ Ø·Ù„Ø¨ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¨Ø§Ø´Ø±Ø©
                    sub_kb = InlineKeyboardMarkup([
                        [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ© â€” 100 Ø¯.Ù„", callback_data=f"pick_sub:gold")],
                        [InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ¶ÙŠØ© â€” 60 Ø¯.Ù„", callback_data=f"pick_sub:silver")]
                    ])
                    await update.message.reply_text("Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªÙØ¹ÙŠÙ„Ù‡ Ø«Ù… Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨:", reply_markup=sub_kb)
                    return
                if state.get("step") == "await_coupon_code":
                    code_input = text.strip()
                    if not code_input:
                        await update.message.reply_text("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ ØµØ§Ù„Ø­."); return

                    # Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© ÙÙŠ DB Ù…Ø¹ Ø¨Ø¹Ø¶ Ø§Ù„ØªØ­ÙˆÙŠØ±Ø§Øª (VIP-.. Ø£Ùˆ Ø¨ØµÙŠØºØ© Ø¨Ø¯ÙˆÙ† Ø£ØµÙØ§Ø± Ø¨Ø§Ø¯Ø¦Ø©)
                    raw = re.sub(r"[^\w\-]", "", code_input.strip().upper())
                    raw_nz = re.sub(r"^0+", "", raw)
                    candidates = []
                    for cand in (raw, raw_nz):
                        if cand:
                            candidates.append(cand)
                            if not cand.startswith("VIP-"):
                                candidates.append("VIP-" + cand)
                    seen = []
                    candidates = [c for c in candidates if c and (c not in seen and not seen.append(c))]

                    conn = sqlite3.connect(DB_PATH)
                    cur = conn.cursor()
                    found = None
                    for c in candidates:
                        cur.execute("SELECT id, amount, used, code FROM coupons WHERE UPPER(code) = ?", (c.upper(),))
                        row = cur.fetchone()
                        if row:
                            found = row
                            break
                    if not found:
                        conn.close()
                        await update.message.reply_text("Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØºÙŠØ± ØµØ§Ù„Ø­."); return
                    cid, amount, used, actual_code = found
                    if used:
                        conn.close()
                        await update.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…ÙØ³ØªØ®Ø¯Ù… Ù…Ø³Ø¨Ù‚Ø§Ù‹."); return

                    desired = state.get("desired_tier")
                    if desired == "gold" and int(amount) != 100:
                        conn.close()
                        await update.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù„ÙŠØ³ Ù…Ø®ØµØµÙ‹Ø§ Ù„Ù„ÙØ¦Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©. Ø§Ø³ØªØ®Ø¯Ù… ÙƒÙˆØ¯Ù‹Ø§ Ø¨ÙØ¦Ø© 100 Ø¯.Ù„."); return
                    if desired == "silver" and int(amount) != 60:
                        conn.close()
                        await update.message.reply_text("Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù„ÙŠØ³ Ù…Ø®ØµØµÙ‹Ø§ Ù„Ù„ÙØ¦Ø© Ø§Ù„ÙØ¶ÙŠØ©. Ø§Ø³ØªØ®Ø¯Ù… ÙƒÙˆØ¯Ù‹Ø§ Ø¨ÙØ¦Ø© 60 Ø¯.Ù„."); return

                    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙˆØ§Ù„Ù…Ø¯Ø© Ø­Ø³Ø¨ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± (Ø§Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ù…ØªØ·Ù„Ø¨Ø§ØªÙƒ)
                    if desired == "gold":
                        level = 1; days = 32; tier_name = "Ø°Ù‡Ø¨ÙŠ"
                    else:
                        level = 2; days = 30; tier_name = "ÙØ¶ÙŠ"
                    expiry = datetime.utcnow() + timedelta(days=days)
                    expiry_iso = expiry.isoformat()

                    try:
                        # ÙˆØ³Ù… Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© ÙƒÙ…Ø³ØªØ®Ø¯Ù…Ø©
                        cur.execute("UPDATE coupons SET used=1, used_by_worker_user_id=?, used_at=? WHERE id=?", (user_id, expiry_iso, cid))
                        # Ø®Ø²Ù‘Ù† Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù…Ø¤Ù‚ØªØ§Ù‹ ÙÙŠ state (Ø³ÙŠØªÙ… Ø­ÙØ¸Ù‡Ø§ Ø¹Ù†Ø¯ Ø­ÙØ¸ Ø§Ù„Ø¹Ø§Ù…Ù„ Ø¨Ø¹Ø¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹)
                        state["subscription_level"] = level
                        state["subscription_expiry"] = expiry_iso
                        state["coupon_code"] = actual_code
                        conn.commit()
                        conn.close()
                        state["step"] = "location"
                        user_states[user_id] = state
                        kb = ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)
                        await update.message.reply_text(f"ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„ÙƒÙˆØ¯ Ù„Ù„ÙØ¦Ø© {tier_name}. Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹' Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ:", reply_markup=kb)
                    except Exception:
                        conn.close()
                        logging.exception("Error while marking coupon used")
                        await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙƒÙˆØ¯. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù….")
                    return
            # redeem flow
            if state.get("role") == "redeem" and state.get("step") == "code":
                code = text.strip(); ok, msg = redeem_coupon_for_worker(code, user_id)
                await update.message.reply_text(msg); user_states.pop(user_id, None); return
    except Exception:
        logging.exception("Error in handle_buttons")
        try:
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø¯Ø§Ø®Ù„ÙŠ. Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ Ø§ÙƒØªØ¨ /start.")
        except Exception:
            pass
    await update.message.reply_text("Ù„Ù… Ø£ÙÙ‡Ù…. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø£Ùˆ Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©.", reply_markup=MAIN_KB)

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        msg = update.message
        if not msg or not msg.contact:
            return
        user_id = msg.from_user.id
        phone_raw = msg.contact.phone_number
        logging.info("handle_contact: user=%s phone=%r", user_id, phone_raw)
        if not phone_raw:
            await msg.reply_text("Ù„Ù… Ù†ØªÙ„Ù‚Ù Ø±Ù‚Ù… Ù‡Ø§ØªÙ. Ø£Ø¹Ø¯ Ù…Ø´Ø§Ø±ÙƒØ© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„."); return
        phone = normalize_phone(phone_raw)
        if not phone:
            await msg.reply_text("Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø³ØªØ®Ø¯Ù… 091xxxxxxx Ø£Ùˆ +2189xxxxxxx."); return
        state = user_states.get(user_id)
        if not state:
            await msg.reply_text("Ø§Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /start."); return
        role = state.get("role"); step = state.get("step")
        if role in ("subscriber", "client") and step == "phone":
            state["phone"] = phone; state["step"] = "location"
            kb = ReplyKeyboardMarkup([[KeyboardButton("Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹", request_location=True)]], resize_keyboard=True, one_time_keyboard=True)
            await msg.reply_text("ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø±Ù‚Ù…Ùƒ. Ø§Ù„Ø¢Ù† Ø´Ø§Ø±Ùƒ Ù…ÙˆÙ‚Ø¹Ùƒ.", reply_markup=kb); return
        if role == "worker" and step == "phone":
            state["phone"] = phone; state["step"] = "coupon"
            await msg.reply_text("Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„ØªÙƒÙ…Ù„Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„."); return
        await msg.reply_text("ØªÙ… Ø­ÙØ¸ Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„. ØªØ§Ø¨Ø¹ Ø£Ùˆ Ø§ÙƒØªØ¨ /start.")
    except Exception:
        logging.exception("Error in handle_contact")
        try:
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¬Ù‡Ø© Ø§Ù„Ø§ØªØµØ§Ù„. Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ /start.")
        except Exception:
            pass

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        if not query:
            return
        await query.answer()
        data = query.data or ""
        user_id = query.from_user.id

        # user chose subscription type during Ø§Ù„ØªØ³Ø¬ÙŠÙ„
        if data.startswith("pick_sub:"):
            parts = data.split(":")
            if len(parts) != 2:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                return
            tier = parts[1]
            state = user_states.get(user_id, {})
            if state.get("role") != "worker":
                await query.edit_message_text("Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§ØµÙŠØ© Ù…ØªØ§Ø­Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø§Ù…Ù„ÙŠÙ† Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„.")
                return
            state["desired_tier"] = tier
            state["step"] = "await_coupon_code"
            user_states[user_id] = state
            try:
                await query.edit_message_text(f"Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª Ø§Ù„ÙØ¦Ø©: {'Ø°Ù‡Ø¨ÙŠØ©' if tier=='gold' else 'ÙØ¶ÙŠØ©'}.\nØ£Ø¯Ø®Ù„ Ø§Ù„Ø¢Ù† ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©:")
            except Exception:
                await query.message.reply_text("Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¢Ù† ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø³ÙŠÙ…Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©:")
            return

        # user chose a worker for their request: format choose:{client_id}:{worker_user_id}
        if data.startswith("choose:"):
            parts = data.split(":")
            if len(parts) != 3:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¹Ø§Ù…Ù„. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                return
            client_id = int(parts[1])
            try:
                worker_user_id = int(parts[2])
            except Exception:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø±Ù Ø§Ù„Ø¹Ø§Ù…Ù„.")
                return
            # Ø³Ø¬Ù„ Ø§Ù„ØªØ¹ÙŠÙŠÙ† ÙÙŠ DB ÙˆØ²Ø¯Ù‘ Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±
            try:
                assign_worker_to_client(client_id, worker_user_id)
                increment_worker_selected(worker_user_id, by=1)
            except Exception:
                logging.exception("Failed to assign worker")
                await query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¹Ø§Ù…Ù„. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
                return
            # ØªØ£ÙƒÙŠØ¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ¥Ø¹Ù„Ø§Ù… Ø§Ù„Ø¹Ø§Ù…Ù„
            await query.edit_message_text("ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù‡Ø°Ø§ Ø§Ù„Ø­Ø±ÙÙŠ ÙˆØ³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù‡. Ø´ÙƒØ±Ø§Ù‹.")
            try:
                # Ø­Ø§ÙˆÙ„ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¹Ø§Ù…Ù„ Ø¥Ù† Ø£Ù…ÙƒÙ†
                await context.bot.send_message(worker_user_id, f"ØªÙ… Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ù„Ø·Ù„Ø¨ Ø±Ù‚Ù… {client_id} Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}.")
            except Exception:
                logging.debug("Could not notify worker (maybe hasn't started the bot).")
            return

        # ÙØªØ­ Ù†Ø§ÙØ°Ø© ØªÙ‚ÙŠÙŠÙ…
        if data.startswith("open_rate:"):
            parts = data.split(":")
            if len(parts) != 2:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ ØµÙØ­Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ….")
                return
            try:
                target_worker = int(parts[1])
            except Exception:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø±Ù Ø§Ù„Ø¹Ø§Ù…Ù„."); return
            # Ø£Ø±Ø³Ù„ Ø£Ø²Ø±Ø§Ø± ØªÙ‚ÙŠÙŠÙ… Ø¨Ø³ÙŠØ·Ø© (1-5)
            kb = InlineKeyboardMarkup([[InlineKeyboardButton(str(i), callback_data=f"rate:{target_worker}:{i}") for i in range(1,6)]])
            try:
                await query.message.reply_text("Ø§Ø®ØªØ± ØªÙ‚ÙŠÙŠÙ…Ùƒ (1-5):", reply_markup=kb)
            except Exception:
                await query.edit_message_text("Ø§Ø®ØªØ± ØªÙ‚ÙŠÙŠÙ…Ùƒ (1-5):")
            return

        # Ø§Ø³ØªÙ„Ø§Ù… ØªÙ‚ÙŠÙŠÙ…
        if data.startswith("rate:"):
            parts = data.split(":")
            if len(parts) < 3:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‚ÙŠÙŠÙ….")
                return
            try:
                target_worker = int(parts[1]); score = int(parts[2])
            except Exception:
                await query.edit_message_text("Ø®Ø·Ø£ ÙÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙ‚ÙŠÙŠÙ…."); return
            # Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
            try:
                save_rating_to_db(target_worker, user_id, score, comment=None)
                await query.message.reply_text("Ø´ÙƒØ±Ø§Ù‹ Ù„ØªÙ‚ÙŠÙŠÙ…Ùƒ.")
            except Exception:
                logging.exception("Failed saving rating")
                await query.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ….")
            return

        # ...existing callback handling for other cases...
    except Exception:
        logging.exception("Error in handle_callback")
        try:
            if update.callback_query:
                await update.callback_query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©.")
        except Exception:
            pass

async def handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_id = update.message.from_user.id
        logging.info("handle_location called for user %s ; update=%r", user_id, update)
        state = user_states.get(user_id)
        if not state:
            await update.message.reply_text("Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø¹Ù…Ù„ÙŠØ© Ø³Ø§Ø¨Ù‚Ø©. Ø§Ø¶ØºØ· Ø£Ø­Ø¯ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ùˆ Ø§ÙƒØªØ¨ /start Ù„Ù„Ø¨Ø¯Ø¡."); return
        if not getattr(update.message, "location", None):
            await update.message.reply_text("Ù„Ù… Ù†ØªÙ„Ù‚Ù Ø§Ù„Ù…ÙˆÙ‚Ø¹. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹' Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ."); return
        lat = update.message.location.latitude; lon = update.message.location.longitude
        # use the shared main keyboard so buttons are consistent for clients
        main_kb = MAIN_KB

        # subscriber branch removed (no more saving subscribers)

        # worker branch (unchanged)
        if state.get("role") == "worker" and state.get("step") in ("location",):
            state["location"] = (lat, lon)
            try:
                worker_id = save_worker_to_db(user_id, state)
            except Exception:
                logging.exception("Failed saving worker")
                await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ù„. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø£Ùˆ Ø§ÙƒØªØ¨ /start.")
                if ADMIN_ID:
                    tb = traceback.format_exc(); await context.bot.send_message(ADMIN_ID, f"Error saving worker {user_id}:\n{tb[:3000]}")
                return
            workers[user_id] = state.copy(); user_states.pop(user_id, None)
            await update.message.reply_text(f"Ø´ÙƒØ±Ø§Ù‹ Ù„ØªØ³Ø¬ÙŠÙ„Ùƒ ÙƒØ¹Ø§Ù…Ù„.\nØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ.\nØ±Ù‚Ù… Ø§Ù„Ù…Ø¹Ø±Ù: {worker_id}", reply_markup=ReplyKeyboardRemove())

            sub_kb = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©", callback_data=f"sub:gold:{worker_id}"),
                    InlineKeyboardButton("Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ¶ÙŠØ©", callback_data=f"sub:silver:{worker_id}")
                ]
            ])
            await update.message.reply_text(
                "Ø§Ø®ØªØ± Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù„ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ù…Ù…ÙŠØ²Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© (Ø£ÙˆÙ„ÙˆÙŠØ© ÙÙŠ Ø§Ù„Ø¸Ù‡ÙˆØ± ÙˆØºÙŠØ±Ù‡Ø§):",
                reply_markup=sub_kb
            )

            await update.message.reply_text("Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:", reply_markup=main_kb); return

        # client request flow unchanged (clients are recorded as requests directly)
        if state.get("role") == "client" and state.get("step") in ("location",):
            state["location"] = (lat, lon)
            service = state.get("service")
            # If this is an educational service request, filter workers by the requested edu_type
            if service == "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©":
                db_workers = fetch_workers_by_service(service, edu_type=state.get("edu_type"))
            else:
                db_workers = fetch_workers_by_service(service)
            MAX_KM = 100.0
            workers_in_range = []
            for w in db_workers:
                try:
                    if not w.get("location") or None in w.get("location"): continue
                    dist_km = calc_distance(state["location"], w["location"])
                    if dist_km <= MAX_KM:
                        workers_in_range.append({
                            "id": w.get("id"),
                            "user_id": w.get("user_id"),
                            "name": w.get("name"),
                            "phone": w.get("phone"),
                            "work_type": w.get("work_type"),
                            "location": w.get("location"),
                            "subscription_level": int(w.get("subscription_level") or 0),
                            "subscription_expiry": w.get("subscription_expiry"),
                            "dist_km": dist_km
                        })
                except Exception:
                    logging.exception("Error computing distance for worker row: %r", w)
            try:
                client_id = save_client_request_to_db(user_id, state, req_id=state.get("request_id"))
            except Exception:
                logging.exception("Failed saving client request")
                await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø·Ù„Ø¨Ùƒ. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ø£Ø®Ø±Ù‰ Ø£Ùˆ Ø§ÙƒØªØ¨ /start.")
                if ADMIN_ID:
                    tb = traceback.format_exc(); await context.bot.send_message(ADMIN_ID, f"Error saving client request {user_id}:\n{tb[:3000]}")
                return
            if not workers_in_range:
                await update.message.reply_text("Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¹Ù…Ø§Ù„ Ù…ØªÙˆÙØ±ÙˆÙ† Ø¨Ù†ÙØ³ Ø§Ù„Ø®Ø¯Ù…Ø© Ø¶Ù…Ù† 100 ÙƒÙ….", reply_markup=ReplyKeyboardRemove())
            else:
                workers_in_range.sort(key=lambda x: (-x["subscription_level"], x["dist_km"]))
                for w in workers_in_range:
                    # Ø²ÙŠØ§Ø¯Ø© Ø¸Ù‡ÙˆØ± Ø§Ù„Ø­Ø±ÙÙŠ Ù„Ø£Ù†Ù†Ø§ Ø³Ø§Ù†Ø¹Ø±Ø¶Ù‡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
                    try:
                        increment_worker_appearance(w['user_id'], by=1)
                    except Exception:
                        logging.debug("Failed increment appearance for worker %s", w['user_id'])
                    block = (
                        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        f"Ø§Ù„Ø§Ø³Ù…: {w.get('name') or '-'}\n"
                        f"Ø§Ù„Ø®Ø¯Ù…Ø©: {w.get('work_type') or service}\n"
                        f"Ø§Ù„Ù‡Ø§ØªÙ: {w.get('phone') or '-'}\n"
                        f"Ø§Ù„Ù…Ø³Ø§ÙØ©: â‰ˆ{w['dist_km']:.1f} ÙƒÙ…\n"
                        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    )
                    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Ø§Ø®ØªØ± Ù‡Ø°Ø§ Ø§Ù„Ø­Ø±ÙÙŠ", callback_data=f"choose:{client_id}:{w['user_id']}"),
                                                InlineKeyboardButton("Ù‚ÙŠÙ‘Ù…", callback_data=f"open_rate:{w['user_id']}")]])
                    await update.message.reply_text(block, reply_markup=kb)
            user_states.pop(user_id, None)
            await update.message.reply_text(f"Ø´ÙƒØ±Ø§Ù‹. Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ: {client_id}", reply_markup=main_kb)
            return

        logging.info("handle_location: unexpected state for user %s -> %s", user_id, state)
        await update.message.reply_text("ØªØ¹Ø°Ù‘Ø± Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /start Ø£Ùˆ Ø²Ø± ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.", reply_markup=main_kb)
    except Exception:
        logging.exception("Error in handle_location")
        try:
            await update.message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø¯Ø§Ø®Ù„ÙŠ Ø¹Ù†Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ÙˆÙ‚Ø¹. Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ Ø§ÙƒØªØ¨ /start.")
        except Exception:
            pass
        if ADMIN_ID:
            tb = traceback.format_exc(); await context.bot.send_message(ADMIN_ID, f"Exception in handle_location for user {user_id}:\n{tb[:3000]}")

async def myid_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    sub = fetch_subscriber_by_user_id(user_id)
    if not sub:
        await update.message.reply_text("Ø£Ù†Øª ØºÙŠØ± Ù…Ø³Ø¬Ù„ ÙƒÙ…Ø´ØªØ±Ùƒ. Ø§Ø³ØªØ®Ø¯Ù… 'sign up for client' Ù„Ù„ØªØ³Ø¬ÙŠÙ„."); return
    await update.message.reply_text(f"Ø±Ù‚Ù… Ø§Ù„ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ùˆ: {sub['id']}")

async def list_subscribers_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    subs = fetch_subscribers()
    if not subs:
        await update.message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´ØªØ±ÙƒÙŠÙ† Ù…Ø³Ø¬Ù„ÙŠÙ†."); return
    lines = [f"{s['id']} â€” {s['name'] or 'Ù„Ø§ Ø§Ø³Ù…'} ({s['phone'] or 'Ù„Ø§ Ù‡Ø§ØªÙ'})" for s in subs[:100]]
    text = "Ø§Ù„Ù…Ø´ØªØ±ÙƒÙˆÙ† (Ø¢Ø®Ø± 100):\n" + "\n".join(lines)
    if len(text) > 4000:
        from io import BytesIO
        bio = BytesIO(text.encode("utf-8")); bio.name = "subscribers.txt"; await update.message.reply_document(bio)
    else:
        await update.message.reply_text(text)

# ---------- Helpers (phone / utils) ----------
def is_valid_phone(s):
    if not s:
        return False
    d = re.sub(r"\D", "", str(s))
    # International starting with country code 2189...
    if d.startswith("218") and len(d) >= 11 and d[3] == "9":
        return True
    # Local formats: 0XXXXXXXXX or 9XXXXXXX
    if d.startswith("0") and len(d) == 10 and d[1] == "9":
        return True
    if len(d) == 8 and d[0] == "9":
        return True
    return False

def normalize_phone(s):
    if not s:
        return None
    d = re.sub(r"\D", "", str(s))
    # drop country code 218 and ensure leading 0
    if d.startswith("218") and len(d) >= 11:
        d = d[3:]
        if not d.startswith("0"):
            d = "0" + d
    elif len(d) == 8 and d[0] == "9":
        d = "0" + d
    elif len(d) == 10 and d.startswith("0"):
        pass
    else:
        return None
    return d

def calc_distance(loc1, loc2):
    """Haversine distance in kilometers between two (lat, lon)."""
    try:
        lat1, lon1 = loc1
        lat2, lon2 = loc2
        R = 6371.0
        phi1 = math.radians(lat1)
        phi2 = math.radians(lat2)
        dphi = math.radians(lat2 - lat1)
        dlambda = math.radians(lon2 - lon1)
        a = math.sin(dphi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2
        return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    except Exception:
        return float("inf")

def make_code(length=8):
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))

# ---------- Safe fetch helpers (add these) ----------
def fetch_workers_by_service(service, edu_type=None):
    """
    Fetch workers by work_type. If service is educational and edu_type is provided,
    filter by education_type as well so clients match only teachers of the requested division.
    """
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        if service == "Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©" and edu_type:
            cur.execute("SELECT id, user_id, name, phone, lat, lon, subscription_level, subscription_expiry, worker_code, work_type, education_type FROM workers WHERE work_type = ? AND education_type = ?", (service, edu_type))
        else:
            cur.execute("SELECT id, user_id, name, phone, lat, lon, subscription_level, subscription_expiry, worker_code, work_type, education_type FROM workers WHERE work_type = ?", (service,))
        rows = cur.fetchall()
        conn.close()
        results = []
        for r in rows:
            results.append({
                "id": r[0],
                "user_id": r[1],
                "name": r[2],
                "phone": r[3],
                "location": (r[4], r[5]),
                "subscription_level": r[6],
                "subscription_expiry": r[7],
                "worker_code": r[8],
                "work_type": r[9],
                "education_type": r[10]
            })
        return results
    except sqlite3.OperationalError:
        return []
    except Exception:
        logging.exception("fetch_workers_by_service failed")
        return []

def fetch_client_request_by_id(rid):
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT id, user_id, name, phone, service, lat, lon, assigned_worker_id FROM clients WHERE id = ?", (rid,))
        r = cur.fetchone()
        conn.close()
        if not r:
            return None
        return {"id": r[0], "user_id": r[1], "name": r[2], "phone": r[3], "service": r[4], "location": (r[5], r[6]), "assigned_worker_id": r[7]}
    except sqlite3.OperationalError:
        return None
    except Exception:
        logging.exception("fetch_client_request_by_id failed")
        return None

def fetch_subscriber_by_id(sid):
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT id, name, phone, lat, lon FROM subscribers WHERE id = ?", (sid,))
        r = cur.fetchone()
        conn.close()
        if not r:
            return None
        return {"id": r[0], "name": r[1], "phone": r[2], "location": (r[3], r[4])}
    except sqlite3.OperationalError:
        return None
    except Exception:
        logging.exception("fetch_subscriber_by_id failed")
        return None

def fetch_subscriber_by_user_id(user_id):
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT id, user_id, name, phone, lat, lon FROM subscribers WHERE user_id = ?", (user_id,))
        r = cur.fetchone()
        conn.close()
        if not r:
            return None
        return {"id": r[0], "user_id": r[1], "name": r[2], "phone": r[3], "location": (r[4], r[5])}
    except sqlite3.OperationalError:
        return None
    except Exception:
        logging.exception("fetch_subscriber_by_user_id failed")
        return None

def fetch_subscribers(limit=100):
    try:
        conn = sqlite3.connect(DB_PATH)
        cur = conn.cursor()
        cur.execute("SELECT id, name, phone FROM subscribers ORDER BY id DESC LIMIT ?", (limit,))
        rows = cur.fetchall()
        conn.close()
        return [{"id": r[0], "name": r[1], "phone": r[2]} for r in rows]
    except sqlite3.OperationalError:
        return []
    except Exception:
        logging.exception("fetch_subscribers failed")
        return []

# Update admin panel to use safe fetch functions
async def send_admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else None
    if not ADMIN_ID or uid != ADMIN_ID:
        await update.message.reply_text("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.")
        return
    try:
        subs = fetch_subscribers()
        sub_count = len(subs)
        conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM workers"); workers_count = cur.fetchone()[0] or 0
        cur.execute("SELECT id, name, phone, work_type, worker_code, subscription_level, subscription_expiry FROM workers ORDER BY id DESC LIMIT 1000"); wrows = cur.fetchall()
        conn.close()
    except Exception:
        logging.exception("send_admin_panel failed")
        await update.message.reply_text("ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.")
        return

    header = f"Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©\nØ§Ù„Ù…Ø´ØªØ±ÙƒÙˆÙ†: {sub_count}\nØ§Ù„Ø¹Ù…Ø§Ù„: {workers_count}\n\n"
    sub_lines = [f"{s['id']} | {s['name'] or '-'} | {s['phone'] or '-'}" for s in subs]
    subs_text = "Ø§Ù„Ù…Ø´ØªØ±ÙƒÙˆÙ† (Ø¢Ø®Ø±):\n" + ("\n".join(sub_lines) if sub_lines else "(Ù„Ø§ Ø³Ø¬Ù„Ø§Øª)")
    w_lines = [f"{wid} | {name or '-'} | {phone or '-'} | {wtype or '-'} | code:{wcode or '-'} | lvl:{level or 0} | exp:{expiry or '-'}" for wid, name, phone, wtype, wcode, level, expiry in wrows]
    workers_text = "Ø§Ù„Ø¹Ù…Ø§Ù„ (Ø¢Ø®Ø±):\n" + ("\n".join(w_lines) if w_lines else "(Ù„Ø§ Ø³Ø¬Ù„Ø§Øª)")
    OUT_LIMIT = 3500
    await update.message.reply_text(header)
    if len(subs_text) > OUT_LIMIT:
        from io import BytesIO
        bio = BytesIO(subs_text.encode("utf-8")); bio.name = "subscribers.txt"
        await update.message.reply_document(bio)
    else:
        await update.message.reply_text(subs_text)
    if len(workers_text) > OUT_LIMIT:
        from io import BytesIO
        bio = BytesIO(workers_text.encode("utf-8")); bio.name = "workers.txt"
        await update.message.reply_document(bio)
    else:
        await update.message.reply_text(workers_text)

async def _global_error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    # Simple global handler: only log the exception server-side.
    try:
        err = getattr(context, "error", None)
        logging.exception("Unhandled exception in update: %s", err or "")
        # Ù„Ø§ Ù†Ø±Ø³Ù„ Ø£ÙŠ ØªÙØ§ØµÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø¯Ù…Ù† Ù…Ù† Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© â€” ÙÙ‚Ø· Ø³Ø¬Ù„ ÙˆØ§ØµÙ„Ø­ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ø¯Ù….
    except Exception:
        logging.exception("Error in global error handler")

if __name__ == "__main__":
    # ØªÙ‡ÙŠØ¦Ø© DB
    init_db()

    # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù‚ÙÙ„ Ø³Ø§Ø¨Ù‚ ÙˆØ­Ø§ÙˆÙ„ Ù‚Ø±Ø§Ø¡ØªÙ‡ (Ù‡Ø§Ø¯Ø¦ØŒ Ù„Ø§ ÙŠÙ‚Ø§Ø·Ø¹ Ø§Ù„ØªØ´ØºÙŠÙ„)
    try:
        if os.path.exists(LOCKFILE):
            try:
                with open(LOCKFILE, "r") as f:
                    old = f.read().strip()
                    logging.info("Found lock file, previous pid: %s", old)
            except Exception:
                logging.debug("Could not read lock file")
    except Exception:
        logging.debug("Lock check failed")

    # Ø§ÙƒØªØ¨ Ù‚ÙÙ„ Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ PID Ø§Ù„Ø­Ø§Ù„ÙŠ
    try:
        with open(LOCKFILE, "w") as f:
            f.write(str(os.getpid()))
    except Exception:
        logging.exception("Could not write lock file")

    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª
    app = Application.builder().token(TOKEN).build()

    # Ø£ÙˆØ§Ù…Ø±
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("redeem", redeem_cmd))
    app.add_handler(CommandHandler("myid", myid_cmd))
    app.add_handler(CommandHandler("list_subscribers", list_subscribers_cmd))

    # Ø±Ø³Ø§Ø¦Ù„ ÙˆØ£Ø²Ø±Ø§Ø±ØŒ Ø¬Ù‡Ø§Øª Ø§ØªØµØ§Ù„ØŒ Ù…ÙˆØ§Ù‚Ø¹ØŒ ÙˆØ§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª callback
    app.add_handler(MessageHandler(filters.CONTACT, handle_contact))
    app.add_handler(MessageHandler(filters.LOCATION, handle_location))
    app.add_handler(CallbackQueryHandler(handle_callback))
    # Ø£ÙŠ Ù†Øµ ØºÙŠØ± Ø£Ù…Ø± ÙŠØ¹Ø§Ù„Ø¬ Ø¨ÙˆØ§Ø³Ø·Ø© handle_buttons
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_buttons))

    # Ù…Ø¹Ø§Ù„Ø¬ Ø£Ø®Ø·Ø§Ø¡ Ø¹Ø§Ù… (ØµØ§Ù…Øª Ù„Ù„Ø£Ø¯Ù…Ù† ÙƒÙ…Ø§ Ø¹Ø¯Ù‘Ù„Ù†Ø§)
    try:
        app.add_error_handler(_global_error_handler)
    except Exception:
        logging.debug("Could not set global error handler")

    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ ØªÙ†Ø¸ÙŠÙ Ù…Ù„Ù Ø§Ù„Ù‚ÙÙ„ Ø¹Ù†Ø¯ Ø§Ù„ØªÙˆÙ‚Ù
    try:
        logging.info("Starting Application (bot) ...")

        # Ensure an asyncio event loop exists on the main thread (fix RuntimeError: no current event loop)
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = None
        if loop is None:
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
            except Exception:
                logging.debug("Could not create/set new event loop; continuing with default behavior.")

        app.run_polling(allowed_updates= ["message", "callback_query", "edited_message", "channel_post", "my_chat_member", "chat_member"])
    except Exception:
        logging.exception("Application.run_polling exited with exception")
    finally:
        try:
            if os.path.exists(LOCKFILE):
                os.remove(LOCKFILE)
        except Exception:
            logging.debug("Could not remove lock file on exit")